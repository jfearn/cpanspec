#!/usr/bin/perl
#
# cpanspec - Generate a spec file for a CPAN module
#
# Copyright (C) 2004-2011 Steven Pritchard <steve@kspei.com>
# This program is free software; you can redistribute it
# and/or modify it under the same terms as Perl itself.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# $Id: cpanspec,v 1.68 2009/01/22 01:48:06 stevenpritchard Exp $

use strict;
use warnings;
use 5.10.1;
use bignum;
$! = 1;

my $NAME    = "cpanspec";
my $VERSION = '2.0_1';

=head1 NAME

cpanspec - Generate a spec file for a CPAN module

cpanget - Download a CPAN module

=head1 SYNOPSIS

cpanspec [options] [module [...]]

cpanget [options] [module [...]]

 Options:
   --help       -h      Help message
   --old        -o      Be more compatible with old RHL/FC releases
   --perl-version   -P  Minimum perl version to support
   --license    -l      Include generated license texts if absent in source
   --noprefix   -n      Don't add perl- prefix to package name
   --force      -f      Force overwriting existing spec
   --packager   -p      Name and email address of packager (for changelog)
   --release    -r      Release of package (defaults to 1)
   --epoch      -e      Epoch of package
   --disttag    -d      Disttag (defaults to %{?dist})
   --srpm       -s      Build a source RPM
   --build      -b      Build source and binary RPMs
   --cpan       -c      CPAN mirror URL
   --verbose    -v      Be more verbose, more v's for more messages
   --prefer-macros  -m  Prefer macros over environment variables in the spec
   --download-only  -D  Only download the tarball from CPAN

 Long options:
   --follow             Process build dependencies
   --filter-requires    Specify Requires to remove
   --filter-provides    Specify Provides to remove
   --add-requires       Add Requires for this item
   --add-provides       Add Provides for this item
   --add-buildrequires  Add BuildRequires for this item
   --version            Print the version number and exit

The modules specified on the command line can be either filenames of tarballs,
or module names as downloadable from CPAN.

=head1 EXAMPLES

cpanspec Linux::Prctl

cpanspec ~/downloads/Acme-MetaSyntactic-0.99.tar.gz

cpanget Module::Build

=head1 DESCRIPTION

B<cpanspec> will generate a spec file to build a RPM from a CPAN-style
Perl module distribution.

B<cpanget> will download the tarball for a module from CPAN. This
implies --download-only and ignores most other options.

=head1 OPTIONS

=over 4

=item B<-h>, B<--help>

Print a brief help message and exit.

=item B<-o>, B<--old>

Be more compatible with old RHL/FC releases.  With this option enabled,
the generated spec file

=over 4

=item *

Defines perl_vendorlib or perl_vendorarch.

=item *

Includes explicit dependencies for core Perl modules.

=item *

Uses C<%check || :> instead of just C<%check>.

=item *

Includes a hack to remove LD_RUN_PATH from Makefile.

=back

=item B<-P>, B<--perl-version>

Include explicit dependencies for core modules when newer versions are
required than shipped with the specified version.

=item B<-l>, B<--license>

Generate COPYING and Artistic license texts if the source doesn't seem
to include them.

=item B<-n>, B<--noprefix>

Don't add I<perl-> prefix to the name of the package.  This is useful
for perl-based applications (such as this one), so that the name of
the RPM is simply B<cpanspec> instead of B<perl-cpanspec>.

=item B<-f>, B<--force>

Force overwriting an existing spec file.  Normally B<cpanspec> will
refuse to overwrite an existing spec file for safety.  This option
removes that safety check.  Please use with caution.

=item B<-S>, B<--stdout>

Write the generated spec file to stdout instead of a file.

=item B<-p>, B<--packager>

The name and email address of the packager.  Overrides the C<%packager>
macro in C<~/.rpmmacros>.

=item B<-r>, B<--release>

The release number of the package.  Defaults to 1.

=item B<-e>, B<--epoch>

The epoch number of the package.  By default, this is undefined, so
no epoch will be used in the generated spec.

=item B<-d>, B<--disttag>

Disttag (a string to append to the release number), used to
differentiate builds for various releases.  Defaults to the
semi-standard (for Fedora) string C<%{?dist}>.

=item B<-D>, B<--download-only>

Only download the upstream tarball, do not generate a specfile. Most
other options are ignored as they are only relevant when creating a
specfile or building a package.

=item B<-s>, B<--srpm>

Build a source RPM from the generated spec file.

=item B<-b>, B<--build>

Build source and binary RPMs from the generated spec file.
B<Please be aware that this is likely to fail!>  Even if it succeeds,
the generated RPM will almost certainly need some work to make
rpmlint happy.

=item B<-c>, B<--cpan>

The URL to a CPAN mirror.  If not specified with this option or the
B<CPAN> environment variable, defaults to L<http://www.cpan.org/>.

=item B<-v>, B<--verbose>

Be more verbose. Can be specified multiple times.

=item B<-m>, B<--prefer-macros>

Prefer the macro form of common spec constructs over the environment variable
form (e.g. %{buildroot} V $RPM_BUILD_ROOT).

=item B<--follow>

Add build dependencies to the list of modules to process.

=item B<--filter-requires>

Specify Requires to remove.

=item B<--filter-provides>

Specify Provides to remove.

=item B<--add-requires>

Add Requires for this item.

=item B<--add-provides>

Add Provides for this item.

=item B<--add-buildrequires>

Add BuildRequires for this item.

=item B<--version>

Print the version number and exit.

=back

=head1 AUTHOR

Steven Pritchard <steve@kspei.com>

=head1 SEE ALSO

L<perl(1)>, L<cpan2rpm(1)>, L<cpanflute2(1)>

=cut

use FileHandle;
use Archive::Tar;
use Archive::Zip qw(:ERROR_CODES);
use POSIX;
use locale;
use Text::Autoformat;
use YAML qw(Load);
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use LWP::UserAgent;
use Parse::CPAN::Packages;
use Pod::Simple::TextContent;
use Module::CoreList;
use Carp qw(carp croak longmess);
use Perl::Version;
use Module::ExtractUse 0.33;
use Symbol 'gensym';
use IPC::Run qw( run );

# Apparently gets pulled in by another module.
#use Cwd;

my %opt;

my $help         = 0;
my $compat       = 0; 
my $perl_version = 0;
my $addlicense   = 0;
my $noprefix     = 0;
my $force        = 0;
my $stdout       = 0;
my $packager;
my $release = 1;
## FIXME hmm if a package fails because the current RPM isn't new enough then we have to check the epoch
### Also if packages use variable length versions we need to set epochs ... e.g. 5.123 < 5.13 in cpan but > in rpm
my $epoch         = 4;
my $disttag       = '%{?dist}';
my $download_only = ( basename($0) eq "cpanget" ) ? 1 : 0;
my $buildsrpm     = 0;
my $buildrpm      = 0;
my $verbose       = 0;
my $follow        = 0;
my $macros        = 0;
my $source;
my $cpan = $ENV{'CPAN'} || "http://www.cpan.org";

my $home = $ENV{'HOME'} || ( getpwuid($<) )[7];
croak("Can't locate home directory.  Please define \$HOME.\n")
    if( !defined($home) );


my $pkgdetails = "$home/.cpan/sources/modules/02packages.details.txt.gz";
my $updated    = 0;

my $packages;
my %repo_cache;
my %corelist;

my @filter_requires;
my @filter_provides;
my @add_requires;
my @add_provides;
my @add_buildrequires;

# env. vars and their macro analogues
my @MACROS = (

    # 0 is for the full expansions....
    {   'optimize'  => '$RPM_OPT_FLAGS',
        'buildroot' => '$RPM_BUILD_ROOT',
    },

    # 1 is for the macros.
    {   'optimize'  => '%{optflags}',
        'buildroot' => '%{buildroot}',
    },
);

# this is set after the parameters are passed
my %macro;

my %dep_blacklist = (
    'Win32'                  => 1,    # We're not on win32
    'Win32::Process'         => 1,    # We're not on win32
    'Win32::API'             => 1,    # We're not on win32
    'Win32::TieRegistry'     => 1,    # We're not on win32
    'Win32::Console'         => 1,
    'DBD::Oracle'            => 1,
    'DBI::db'                => 1,    # part of DBD::Oracle
    'BaseClass'              => 1,    # Common test class shipped by ourselves
    'TestServer'             => 1,    # Likewise
    'of'                     => 1,    # o_O
    'Test::DependentModules' => 1,
    'Blarg'                  => 1,
    'MyApp'                  => 1,
    'CPAN::Config'           => 1,    # FIXME how is this getting detected?
    'VMS::Filespec'          => 1,
    'Test::Run::Builder'     => 1,    # FIXME things in inc should be ignored
    'Test::Kwalitee'         => 1,    # almost never a real dep
    'MyModuleBuilder'        => 1,
    'indirect'               => 1,

);

# FIXME deal with modules with incompatible versioning histories.
# Is there a better way to get rpm to grok 5.562 < 5.57 ?
# $ rpmdev-vercmp 5.562 5.57
# 5.562 > 5.57
# $ rpmdev-vercmp 0:5.562 1:5.57
# 0:5.562 < 1:5.57
#
# perl -e 'use Perl::Version; my $v1 = Perl::Version->new( q{5.562} ); my $v2 = Perl::Version->new( q{5.57} ); print ($v1->vcmp( $v2 ) > 0 ? "yes" : "no"), "\n";'
# yes

my %min_versions = ( 'Exporter' => '5.57', );

# Set locale to en_US.UTF8 so that dates in changelog will be correct
# if using another locale. Also ensures writing out UTF8. (Thanks to
# Roy-Magne Mo for pointing out the problem and providing a solution.)
setlocale( LC_ALL, "en_US.UTF-8" );

my $wd_path = '/cpanspec';

GetOptions(
    'help|h'              => \$help,
    'old|o'               => \$compat,
    'perl-version|P=s'    => \$perl_version,
    'license|l'           => \$addlicense,
    'noprefix|n'          => \$noprefix,
    'force|f'             => \$force,
    'stdout|S'            => \$stdout,
    'packager|p=s'        => \$packager,
    'release|r=i'         => \$release,
    'epoch|e=i'           => \$epoch,
    'disttag|d=s'         => \$disttag,
    'download-only|D'     => \$download_only,
    'srpm|s'              => \$buildsrpm,
    'build|b'             => \$buildrpm,
    'cpan|c=s'            => \$cpan,
    'verbose|v+'          => \$verbose,
    'follow'              => \$follow,
    'filter-requires=s'   => \@filter_requires,
    'filter-provides=s'   => \@filter_provides,
    'add-requires=s'      => \@add_requires,
    'add-provides=s'      => \@add_provides,
    'add-buildrequires=s' => \@add_buildrequires,
    'version'             => \&print_version,
    'prefer-macros|m'     => \$macros,
    'path=s'              => \$wd_path,
) || pod2usage( { -exitval => 1, -verbose => 0 } );

pod2usage( { -exitval => 0, -verbose => 1 } ) if($help);
pod2usage( { -exitval => 1, -verbose => 0 } ) if( !@ARGV );


my $repo_path = $wd_path . '/repo';
my $prefix    = $noprefix ? "" : "perl-";
my @args      = @ARGV;
my @processed = ();
my $dnf;
my %created_specfiles;

update_packages();
init();

$packages = Parse::CPAN::Packages->new($pkgdetails)
    if( !defined($packages) );
croak("Parse::CPAN::Packages->new() failed: $!\n")
    if( !defined($packages) );

for my $mod (@args) {
    if( $buildrpm && $follow ) {
        if( $mod =~ /src\.rpm$/ ) {
            build_n_install( $mod, "$home/rpmbuild/" );
        }
        else {
            $mod =~ s/::/-/g;
            my $spec = "perl-$mod.spec";

            if( -f $spec ) {
                build_n_install( $spec, "$spec-build/" );
            }
            else {
                # check if it's a non-perl dep!
                if( my $pkg = check_src_rpm($mod) ) {
                    my $srpm = download_srpm($pkg);
                    build_n_install( $srpm, "$home/rpmbuild/" );
                }
                else {
                    process_module($mod);
                }
            }
        }
    }
    else {
        process_module($mod);
    }
}

if( $buildrpm && $follow ) {

    run_cmd2(
        [   'find',  "$wd_path",
            '-name', "*.src.rpm",
            '-type', 'f'
        ],
        '|',
        [   'xargs', '--no-run-if-empty', 'cp', '-v', '-a', '-t',
            "$wd_path/SRPMS"
        ]
    );

    run_cmd2(
        [   'find',  "/root/rpmbuild",
            '-name', "*.src.rpm",
            '-type', 'f'
        ],
        '|',
        [   'xargs', '--no-run-if-empty', 'cp', '-v', '-f', '-a', '-t',
            "$wd_path/SRPMS"
        ]
    );
}

exit;

###################################################
#

sub process_module {
    my $file = shift();

    my %build_order;
    my $count = -1;
    my( @build_order, @build_reqs, @add_reqs, @filter_reqs );

    my( $name, $version, $type );
    $count++;
    verbose( longmess("Starting loop for $file") );
    if( $file =~ /^(?:.*\/)?(.*)-(?:v\.?)?([^-]+)\.(tar)\.(?:gz|bz2)$/ ) {
        $name    = $1;
        $version = $2;
        $type    = $3;
    }
    elsif( $file =~ /^(?:.*\/)?(.*)-(?:v\.?)?([^-]+)\.tgz$/ ) {
        $name    = $1;
        $version = $2;
        $type    = 'tar';
    }
    elsif( $file =~ /^(?:.*\/)?(.*)-(?:v\.?)?([^-]+)\.(zip)$/ ) {
        $name    = $1;
        $version = $2;
        $type    = $3;
    }
    else {
        # keep things happy if we get "Foo-Bar" instead of "Foo::Bar"
        $file =~ s/-/::/g;

        # Look up $file in 02packages.details.txt.
        my( $m, $d );
        if( $m = $packages->package($file) and $d = $m->distribution() ) {
            my $nist = $d->dist();
            $nist =~ s/-/::/g;
            verbose("Is $nist provided by another package?");
            if( grep { $_ eq $nist } @processed ) {
                warn("Skipping $file, provided by another dep\n");
                return;
            }
            $source = $cpan . "/authors/id/" . $d->prefix();
            $file   = "$wd_path/" . basename( $d->filename() );
            fetch( $source, $file );
            return if($download_only);

            $name    = $d->dist();
            $version = $d->version();
            $version =~ s/^v\.?//;
            if( $file =~ /\.(tar)\.gz$/ ) {
                $type = $1;
            }
            elsif( $file =~ /\.tgz$/ ) {
                $type = 'tar';
            }
            elsif( $file =~ /\.(zip)$/ ) {
                $type = $1;
            }
            else {
                warn "Failed to parse '$file', skipping...\n";
                next;
            }
        }
        else {
            warn
                "Failed to parse '$file' or find a module by that name, skipping...\n";
            return;
        }
    }

    my $module = $name;
    $module =~ s/-/::/g;

    croak("you can't update perl using cpanspec!") if( $module eq 'perl' );

    ## FIXME this really needs to check everything in the module ...
    my $iscore = exists( $corelist{$module} ) || defined( $corelist{$name} );
    verbose(
        "$module or $name is supplied by core perl, moving package content to vendor paths to avoid conflicts."
    ) if($iscore);

    my $archive;
    my $path;
    if( $type eq 'tar' ) {
        my $f = $file;
        if( $file =~ /\.bz2$/ ) {
            eval { use IO::Uncompress::Bunzip2; };

            if($@) {
                warn "Failed to load IO::Uncompress::Bunzip2: $@\n";
                warn "Skipping $file...\n";
                next;
            }

            $f = IO::Uncompress::Bunzip2->new($file);
            if( !defined($f) ) {
                warn "IO::Uncompress::Bunzip2->new() failed on $file: $!\n";
                next;
            }
        }
        $archive = Archive::Tar->new( $f, 1 )
            || croak("Archive::Tar->new() failed: $!\n");
    }
    elsif( $type eq 'zip' ) {
        $archive = Archive::Zip->new()
            || croak("Archive::Zip->new() failed: $!\n");
        croak("Read error on $file\n")
            unless( $archive->read($file) == AZ_OK );
    }

    my @files;

    my $bogus = 0;
    for my $entry ( list_files( $archive, $type ) ) {
        next if( $type eq 'tar' and $entry eq 'pax_global_header' );

        if( $entry !~ /^(?:.\/)?($name(?:-(?:v\.?)?$version)?)(?:\/|$)/ ) {
            warn "BOGUS PATH DETECTED: $entry\n";
            $bogus++;
            next;
        }
        elsif( !defined($path) ) {
            $path = $1;
        }

        $entry =~ s,^(?:.\/)?$name(?:-(?:v\.?)?$version)?/,,;
        next if( !$entry );

       # ignore supplied or extranious directories, starting to hate distzilla
        next
            if($entry =~ m{^(?:eg|tools|inc)/}
            || $entry =~ m{Conflicts.pm$} );
        push( @files, $entry );
    }
    if($bogus) {
        warn "Skipping $file with $bogus path elements!\n";
##        next; # FIXME hmm not sure this is worth enforcing if things work anyway, and having it does break some cpan modules.
    }

    my $url = "http://search.cpan.org/dist/$name/";

    $source = $source
        || "http://www.cpan.org/modules/by-module/"
        . (
        $module =~ /::/
        ? ( split "::", $module )[0]
        : ( split "-", $name )[0]
        )
        . "/"
        . basename($file);
    $source =~ s/$version/\%{version}/;

    my( $description, $summary ) = get_description(
        archive  => $archive,
        type     => $type,
        filename => $file,
        name     => $name,
        module   => $module,
        version  => $version,
        files    => \@files,
        path     => $path,
    );

    if( defined($description) and $description ) {
        $description = autoformat $description,
            {
            "all"     => 1,
            "left"    => 1,
            "right"   => 75,
            "squeeze" => 0,
            };
        $description =~ s/\n+$//s;
    }
    else {
        $description = "$module Perl module";
    }

    $summary = "$module Perl module" if( !defined($summary) );

    my %my_provides = get_provides(
        archive => $archive,
        type    => $type,
        module  => $module,
        files   => \@files,
        path    => $path,
    );

    # To much crap in the world, just match know docs
    my @doc = sort { $a cmp $b } grep {
            $_ =~ "README.*"
            or $_ eq "doc"
            or $_ eq "docs"
            or $_ eq "COPYING"
            or $_ eq "LICENSE"
            or $_ =~ /^Changes$/i
            or $_ =~ /^TODO$/i
    } @files;

    my $date = strftime( "%a %b %d %Y", localtime );

  # FIXME Ignore test files, we only care if the module compiles stuff to ship
    my $noarch = !grep /(?!^t\/.*)\.(c|h|xs|inl)$/i, @files;
    if( $module eq 'DynaLoader::Functions' ) {
        verbose( join( "\n", @files ) );
        push( @filter_reqs, 'VMS::Filespec' );
        $noarch = 1;
    }

    my $vendorlib = ( $noarch ? "vendorlib" : "vendorarch" );
    my $lib = "\%{perl_$vendorlib}";

# FIXME any modules that are black listed and detected as deps need to be added to the filter_requires
# after all deps are processed or the rpm dep checker will add it.
# FIXME BUGBUG this is really broken as these are applied to all following packages as well
# FIXME move this to an external config file so it's easier to update and track
    if( $module eq 'Data::ObjectDriver' ) {
        push( @filter_reqs, 'DBD::Oracle' );
        push( @filter_reqs, 'DBI::db' );
    }
    elsif( $module eq 'JSON::RPC' ) {
        push( @filter_reqs, 'MyApp' );
    }
    elsif( $module eq 'Test::Class::Most' ) {
        push( @build_reqs, 'perl(Test::Differences)' );
    }
    elsif( $module eq 'namespace::autoclean' ) {
        push( @filter_reqs, 'MooseX::Role::WithOverloading' );
        push( @filter_reqs, 'MooseX::Role::Parameterized' );
    }
    elsif( $module eq 'List::SomeUtils' ) {
        push( @filter_reqs, 'Test::Code::TidyAll' );
        push( @filter_reqs, 'List::SomeUtils::XS' );
    }
    elsif( $module eq 'MooseX::Types::Path::Class' ) {
        push( @filter_reqs, 'MooseX::Getopt' );
    }

    if(@filter_provides) {
        my $script = "$name-filter-provides.sh";
        verbose("Writing $script...");
        my $sh;
        if($force) {
            rename( $script, "$script~" ) if( -e $script );
            $sh = new FileHandle ">$script";
        }
        else {
            $sh = new FileHandle $script, O_WRONLY | O_CREAT | O_EXCL;
        }
        croak("Failed to create $script: $!\n") if( !$sh );

        print $sh "#!/bin/sh\n\n"
            . "\@\@PERL_PROV\@\@ \"\$\@\" | sed -e '/^$filter_provides[0]\$/d'";
        if( @filter_provides > 1 ) {
            for my $dep ( @filter_provides[ 1 .. $#filter_provides ] ) {
                print $sh " \\\n    -e '/^$dep\$/d'";
            }
        }
        print $sh "\n";
    }

    my $specfile = "$prefix$name.spec";
    croak("already wrote $specfile")
        if( exists( $created_specfiles{$specfile} ) );
    $created_specfiles{$specfile} = 1;
    verbose("Writing $specfile...");
    verbose( getcwd() . "/$specfile" );
    my $spec;
    if($stdout) {
        $spec = *STDOUT;
    }
    elsif($force) {
        rename( $specfile, "$specfile~" ) if( -e $specfile );
        $spec = new FileHandle ">$specfile";
    }
    else {
        $spec = new FileHandle "$specfile", O_WRONLY | O_CREAT | O_EXCL;
    }

    if( !$spec ) {
        warn "Failed to create $specfile: $!\n";
        next;
    }

    print $spec
        qq[\%{!?perl_$vendorlib: \%define perl_$vendorlib \%(eval "\`\%{__perl} -V:install$vendorlib\`"; echo \$install$vendorlib)}\n\n]
        if($compat);

    my $license    = "";
    my $my_builder = 'Module::Build';

    # TODO It's possible these need to be listed instead of just detected.
    my $uses_autoinstall = grep /Module\/AutoInstall.pm/, @files;
    my $scripts = ( grep /^(?:bin|scripts?|tools)\//, @files );
    my $makecontent;
    if( grep /^Makefile\.PL$/, @files
        and $makecontent = extract( $archive, $type, "$path/Makefile.PL" ) )
    {
        $scripts ||= $makecontent =~ 'install_script';
        $scripts ||=
            (      $makecontent =~ /EXE_FILES/
                && $makecontent !~ /EXE_FILES.*\[\s*(qw\(\s*\)\s*)?\]/ )
            ? 1
            : 0;
    }
    if( grep /^Build\.PL$/, @files
        and $makecontent = extract( $archive, $type, "$path/Build.PL" ) )
    {
        $scripts ||= ( $makecontent =~ 'script_files'
                && $makecontent !~ /script_files['"]?\s*=>\s*\[\]/ );
        if($scripts) {
            $makecontent =~ /(script_files.*)/;
            verbose("\n\nFound scripts: $1");
        }
        if( $makecontent =~ /use (Module::Build::[^\s;]*)/ ) {
            $my_builder = $1;
        }
    }

    # FIXME only works for most simple case
    if( $makecontent =~ /'?LIBS'?\s*=>\s*\[([^\]]*)\]/sm ) {
##        verbose($makecontent);
        foreach my $lib ( split( /\s+/, $1 ) ) {
            verbose("Found lib $lib ...");
            $lib =~ s/-l//i;
            $lib =~ s/['"]//g;
            $lib =~ s/[;,]$//;
            next if( $lib eq 'm' );

            if( !$lib || $lib !~ /\S/ ) {
                $makecontent =~ /'?LIBS'?\s*=>\s*\[(.*)\]/s;
                verbose("Empty lib found for $module: $1");
                next;
            }

            # FIXME blows up on variables :(
            if( $lib =~ /\$([\w-]*)/ ) {
                my $test = $1;
                verbose("lib: $lib");

  # Dirty dirty hack to try and find out what commands are being used for libs
                if( $makecontent =~ /$test\s*=[\W]*([-\w]*)/ ) {
                    my $cmd = $1;
                    $test = check_repo( "*/$cmd", 0 ) || check_rpm("*/$cmd");
                    unless($test) {
                        verbose("Can't work out what provides: $cmd");
                        next;
                    }
                    really_chomp($test);
                    $lib = $test;
                    if( $test =~ /^(.*)-devel/ ) {
                        $lib = $1;
                    }
                    $lib =~ s/mingw\d*-//
                        ;    # chop off cross platform bit if we got it
                    verbose("found $lib for $cmd");
                }
                else {
                    verbose("Can't handle LIBS with variables in them :(");
                    next;
                }
            }
            else {
                my $pkg
                    = ( check_rpm( "$lib", 0 ) || check_repo( "$lib", 0 ) );
                $pkg
                    = (    check_rpm( "pkgconfig($lib)", 0 )
                        || check_repo( "pkgconfig($lib)", 0 ) )
                    unless($pkg);
                $pkg
                    = (    check_rpm( "pkgconfig(lib$lib)", 0 )
                        || check_repo( "pkgconfig(lib$lib)", 0 ) )
                    unless($pkg);
                if($pkg) {
                    $pkg =~ s/-devel//;
                    verbose("found $pkg for $lib");
                    $lib = $pkg;
                }
                else {
                    verbose("Could not work out what provides $lib");
                }
            }

            push( @add_reqs,   "$lib" );
            push( @build_reqs, "$lib-devel" );
        }
    }

    # FIXME only works for most simple case
    if( $makecontent =~ /ExtUtils::PkgConfig->find\(['"](.*)['"]\)/ ) {
        my $dep = $1;
        my $cmd
            = q{repoquery --quiet  -s --whatprovides }
            . $dep
            . q{.\* | head -n1 | perl -p -e 's/-[^-]*.src.rpm//g' | xargs repoquery --quiet --qf "%{NAME}"};

        $cmd
            = q{dnf  --quiet repoquery -s --whatprovides }
            . $dep
            . q{.\* | head -n1 | perl -p -e 's/-[^-]*.src.rpm//g' | xargs dnf --quiet repoquery --qf "%{NAME}"}
            if( which("dnf") );
        verbose("Running 1: $cmd");
        my $lib = qx/$cmd/;
        verbose("lib: $lib");
        really_chomp($lib);

        push( @add_reqs,   "$lib" );
        push( @build_reqs, "$lib-devel" );
    }

    my( %build_requires, %requires );
    my( $yml,            $meta );

    if( grep /^META\.yml$/, @files
        and $yml = extract( $archive, $type, "$path/META.yml" ) )
    {

        # Basic idea borrowed from Module::Depends.
        my $meta;
        eval { $meta = Load($yml); };
        if($@) {
            $yml =~ s/version_regexp: (.*)/version_regexp: '$1'/g;
            eval { $meta = Load($yml); };
            if($@) {
                carp "Error parsing $path/META.yml: $@";
                goto SKIP;
            }
        }

        %build_requires = %{ $meta->{build_requires} }
            if( $meta->{build_requires} );
        %build_requires
            = ( %build_requires, %{ $meta->{configure_requires} } )
            if( $meta->{configure_requires} );
        %requires = %{ $meta->{requires} } if( $meta->{requires} );

## FIXME recommends often causes circular deps.
## Make this optional or make it work better...
    # FIXME This should be added back for rpm versions that support reccomends
        if( 0 && $meta->{recommends} ) {
            for my $dep ( keys( %{ $meta->{recommends} } ) ) {
                $requires{$dep} = $requires{$dep}
                    || $meta->{recommends}->{$dep};
            }
        }

        # FIXME - I'm not sure this is sufficient...
        if(    $meta->{script_files}
            || $meta->{scripts}
            || ( grep m{^bin/.+$|^script(s)?/.+|^arch/.+$}, @files ) )
        {
            $scripts = 1;
        }

        if( $meta->{license} ) {

            # This list of licenses is from the Module::Build::API
            # docs, cross referenced with the list of licenses in
            # /usr/share/rpmlint/config.
            if( $meta->{license} =~ /^perl$/i ) {
                $license = "GPL+ or Artistic";
            }
            elsif( $meta->{license} =~ /^apache$/i ) {
                $license = "Apache Software License";
            }
            elsif( $meta->{license} =~ /^artistic$/i ) {
                $license = "Artistic";
            }
            elsif( $meta->{license} =~ /^artistic_?2$/i ) {
                $license = "Artistic 2.0";
            }
            elsif( $meta->{license} =~ /^bsd$/i ) {
                $license = "BSD";
            }
            elsif( $meta->{license} =~ /^gpl$/i ) {
                $license = "GPL+";
            }
            elsif( $meta->{license} =~ /^lgpl$/i ) {
                $license = "LGPLv2+";
            }
            elsif( $meta->{license} =~ /^mit$/i ) {
                $license = "MIT";
            }
            elsif( $meta->{license} =~ /^mozilla$/i ) {
                $license = "MPL";
            }
            elsif( $meta->{license} =~ /^cc0$/i ) {
                $license = "CC0";
            }
            elsif( $meta->{license} =~ /^open_source$/i ) {
                $license = "OSI-Approved";    # rpmlint will complain
            }
            elsif( $meta->{license} =~ /^unrestricted$/i ) {
                $license = "Distributable";
            }
            elsif( $meta->{license} =~ /^restrictive$/i ) {
                $license = "Non-distributable";
                warn "License is 'restrictive'."
                    . "  This package should not be redistributed.\n";
            }
            else {
                warn "Unknown license '" . $meta->{license} . "'!\n";
                $license = "CHECK(Distributable)";
            }
        }
    SKIP:
    }

    # FIXME weird EXE_FILES setting when it has none ...
    $scripts = 0
        if(( $module eq 'Exporter::Tiny' )
        || ( $module eq 'File::Find::Object' ) );

    if( my @licenses = grep /license|copyright|copying/i, @doc ) {
        if( !$license ) {
            $license = "Distributable, see @licenses";
        }
        elsif(
            $license =~ /^(OSI-Approved|Distributable|Non-distributable)$/ )
        {
            $license .= ", see @licenses";
        }
    }
    $license = "CHECK(GPL+ or Artistic)" if( !$license );

    # some modules have deps missing from META so just check anyway
    # some other modules have broken META.yaml files as well :(
    my $p = Module::ExtractUse->new;
    my $has_modules = 0;
    foreach my $file ( grep /\.(?:PL|pm)$/, @files ) {
        next if( $file =~ m{Conflicts.pm$} );
        my $code = extract( $archive, $type, "$path/$file" );
        $p->extract_use( \$code );
        if($file =~ /.pm$/) {
            $has_modules = 1;
            warn $file;
        }
    }

    map {
        $build_requires{$_} = 0
            if( $_
            !~ /^(?:$name|[\d\.]*|strict|warnings|Config|base|5|lib|constant|.*[\$].*)$/
            && ( !exists( $my_provides{$_} ) )
            && ( !exists( $build_requires{$_} ) ) )
    } @{ $p->arrayref_out_of_eval() };

    # Add build dependencies for modules used in tests.
    my @tests = grep { $_ eq "test.pl" || $_ =~ /^t\/.*\.t$/ } @files;
    use Module::ExtractUse;
    my %bogus_dep = ();
    for my $testfile (@tests) {
        my $extract_o_matic = Module::ExtractUse->new()
            || croak("Module::ExtractUse->new failed: $!\n");
        my $test = extract( $archive, $type, $path . '/' . $testfile );
        if( !defined($test) ) {
            warn "Failed to extract $testfile from $archive: $!\n";
            next;
        }
        $extract_o_matic->extract_use( \$test );

        # lots of tests have recursive deps in evals.
        for my $dep ( $extract_o_matic->array_out_of_eval() ) {
            next if( $dep eq $module );
            next if exists $build_requires{$dep};
            next if exists $bogus_dep{$dep};
            my $package = $packages->package($dep);
            if( !defined($package) ) {
                $bogus_dep{$dep}++;

                # Don't print this for common false positives
                unless( $dep =~ /^(Config|base|5|lib)/ ) {
                    verbose(
                        "Module not on CPAN, not adding dependency: $dep");
                }
                next;
            }
            if(    ( $package->distribution->dist eq $name )
                || ( exists( $my_provides{$name} ) ) )
            {
                verbose(
                    "Dependency $dep provided by ourselves, not adding dependency"
                );
                next;
            }
            $build_requires{$dep} ||= 0;
        }
    }

    my $usebuildpl = 0;

    # FIXME <sigh> other build modules use Build.PL :(
    if( grep /^Build\.PL$/, @files ) {
        $build_requires{$my_builder} ||= 0;
        $usebuildpl = 1;
    }
    else {
        $build_requires{'ExtUtils::MakeMaker'} ||= 0;
    }

    print $spec <<END;
Name:           $prefix$name
Version:        $version
Release:        $release$disttag
END

    print $spec "Epoch:          $epoch\n" if( defined($epoch) );

    print $spec <<END;
Summary:        $summary
License:        $license
Group:          Development/Libraries
URL:            $url
Source0:        $source
BuildRoot:      \%{_tmppath}/\%{name}-\%{version}-\%{release}-root-\%(\%{__id_u} -n)
END

    printf $spec "%-16s%s\n", "BuildArch:", "noarch" if($noarch);

    if( defined( $requires{perl} ) ) {
        $build_requires{perl} = $build_requires{perl} || $requires{perl};
        delete $requires{perl};
    }

    if( defined( $build_requires{perl} ) ) {
        $build_requires{perl} =~ s/^[<>=]+ *//;
        printf $spec "%-16s%s >= %s\n", "BuildRequires:", "perl",
            ( ( $build_requires{perl} lt "5.6.0" ? "0:" : "1:" )
            . $build_requires{perl} )
            if $build_requires{perl};
        delete $build_requires{perl};
    }

    for my $dep ( keys(%requires) ) {
        $build_requires{$dep} = ( $build_requires{$dep} || $requires{$dep} );
    }

    for my $dep ( sort( keys(%build_requires) ) ) {
        if(    exists( $dep_blacklist{$dep} )
            || exists( $my_provides{$dep} )
            || $dep eq $module
            || $dep =~ /^Win32::/
            || $dep =~ /^[\d\.\_]*$/
            || $dep =~ /^t::/
            || $dep =~ /^inc::/ )
        {
            delete( $build_requires{$dep} );
            delete( $requires{$dep} );
            next;
        }

        if( $dep =~ /^(?:lib|strict|warnings)$/ ) {
            delete( $build_requires{$dep} );
            delete( $requires{$dep} );
            next;
        }

        if( grep { $_ eq $dep } ( @filter_requires, @filter_reqs ) ) {
            delete( $build_requires{$dep} );
            delete( $requires{$dep} );
            next;
        }

# FIXME need to catch use in eval in tests as it's often recursive and almost always optional
        if( (      $module eq 'HTML::TreeBuilder::LibXML'
                && $dep eq 'Web::Scraper'
            )
            || (   $module eq 'Devel::CallParser'
                && $dep eq 'Data::Alias' )    ## Recursive
            || (   $module eq 'Devel::CallParser'
                && $dep eq 'Sub::StrictDecl' )    ## Recursive
            )
        {
            $build_requires{$dep} = undef;
            next;
        }

# Who would have thought spamming versions in to deps would make them worthless?
        $build_requires{$dep} = 0 if( $dep eq 'Module::Build' );

        verbose(  "for $module $dep comparing "
                . $build_requires{$dep} . ", "
                . ( $min_versions{$dep} || 0 )
                . "\n" );
        $build_requires{$dep} = "" . ( $build_requires{$dep} || 0 );
        $build_requires{$dep}
            = "" . max( $build_requires{$dep}, ( $min_versions{$dep} || 0 ) )
            if( exists( $min_versions{$dep} ) );

        if( exists( $corelist{$dep} )
            && $corelist{$dep} ge $build_requires{$dep} )
        {
            next if( !$compat );
        }
        elsif($follow) {
            if( $dep ne $module ) {
                if( grep { $_ eq $dep } @processed ) {

             # move the dep after this one as the order gets reversed to build
                    verbose("$dep for $module already processed");
                    $build_order{$dep} = $count + 1;
                }
                elsif( grep { $_ eq $dep } @args ) {

          # move the module after this one as the order gets reversed to build
                    verbose("$dep for $module already added to args");
                    $build_order{$module} = $count + 1;
                }
                elsif( check_dep( $dep, $build_requires{$dep} ) ) {
                    verbose(
                        "$dep >= $build_requires{$dep} is available, skipping."
                    );
                }
                else {
                    verbose(
                        "$dep >= $build_requires{$dep} is not available for $module, adding it to the list.\n"
                    );
                    my $spec = "perl-$dep.spec";
                    process_module($dep)
                        ;    ## FIXME is process_module really create_spec?
                }
            }
        }

        printf $spec "%-16s%s", "BuildRequires:", "perl($dep)"
            unless( ( grep { $_ eq $dep } ( @filter_requires, @filter_reqs ) )
            || ( $dep =~ m{::Conflicts} ) )
            ; # Conflicts seems like intermediate stuff, shouldn't be in lib/?
        print $spec " >= " . $build_requires{$dep}
            if( $build_requires{$dep} );
        print $spec "\n";
    }

    # FIXME Move these to an external config file
    ## FIXME modules that don't require deps properly :-/
    push( @build_reqs, 'subversion' ) if( $module eq 'SVN::Look' );

    # FIXME odd lib declartion
    if( $module eq 'XML::GDOME' ) {
        push( @add_reqs,   "gdome2" );
        push( @build_reqs, "gdome2-devel" );
        push( @add_reqs,   "libxml2" );
        push( @build_reqs, "libxml2-devel" );
    }

    if( $module eq 'Crypt::OpenSSL::VerifyX509' ) {
        push( @build_reqs, "openssl-devel" );
        push( @add_reqs,   "openssl-libs" );
    }

    for my $dep ( @add_buildrequires, @build_reqs ) {
        printf $spec "%-16s%s\n", "BuildRequires:", $dep;
    }

    for my $dep ( sort( keys(%requires) ) ) {
        next if( !$compat and exists( $corelist{$dep} ) );
        printf $spec "%-16s%s", "Requires:", "perl($dep)";
        print $spec " >= " . $requires{$dep}
            if( $requires{$dep} );
        print $spec "\n";
    }

    printf $spec "%-16s%s\n", "Provides:", "perl($module) = $epoch:$version";

    for my $dep ( @add_requires, @add_reqs ) {
        printf $spec "%-16s%s\n", "Requires:", $dep;
    }

    if( !$compat ) {
        print $spec <<END;
Requires:       perl(:MODULE_COMPAT_\%(eval "`\%{__perl} -V:version`"; echo \$version))
END
    }

    for my $prov (@add_provides) {
        printf $spec "%-16s%s\n", "Provides:", $prov;
    }

    my $buildpath = $path;
    $buildpath =~ s/$version/\%{version}/;

    if( @filter_requires || @filter_provides || @filter_reqs ) {
        print $spec "\n" . '%{?perl_default_filter}' . "\n";
    }

    if(@filter_provides) {
        verbose( "filter_provides: " . join( ',', @filter_provides ) );
        foreach my $dep (@filter_provides) {
            print $spec
                '%global __provides_exclude %__provides_exclude|^perl\\('
                . $dep . '\\)$' . "\n";
        }

    }

    if( @filter_requires || @filter_reqs ) {
        verbose( "filter_requires: "
                . join( ',', ( @filter_requires, @filter_reqs ) ) );
        foreach my $dep ( @filter_requires, @filter_reqs ) {
            print $spec
                '%global __requires_exclude %__requires_exclude|^perl\\('
                . $dep . '\\)$' . "\n";
        }

    }
    print $spec <<END;

\%description
$description

\%prep
\%setup -q@{[($noprefix ? "" : " -n $buildpath")]}
END

    if( grep { $_ eq "pm_to_blib" } @files ) {
        print $spec <<'END';

rm -f pm_to_blib
END
    }

    print $spec <<END;

\%build
END

    if($uses_autoinstall) {
        print $spec <<END
export PERL_AUTOINSTALL="--skipdeps"
END
    }

    # https://fedoraproject.org/wiki/Perl/Draft:INC_directories
    #    my $instdir = $iscore ? 'vendor' : $usebuildpl ? 'core' : 'perl';
    my $instdir = $iscore ? 'site' : $usebuildpl ? 'vendor' : 'perl';
    my $paths
        = qq{INSTALLVENDORMAN3DIR=$macro{buildroot}%{perlvendorman3} INSTALLVENDORMAN1DIR=$macro{buildroot}%{perlvendorman1}};

    # FIXME probably should make this behavior optional
    # For packages that override core packages
    $paths
        = "INSTALLSITEMAN3DIR=/usr/local/share/man/man3 INSTALLSITEMAN1DIR=/usr/local/share/man/man1 INSTALLSITEBIN=/usr/local/bin"
        if($iscore);

    # BUGBUG breaks packages on rhel6...
##    $paths = "";

    if($usebuildpl) {
        $paths = "";    #lc($paths); ## Confilcts with Module::Build::Simple??

        print $spec <<END;
\%{__perl} Build.PL --installdirs=$instdir@{[$noarch ? '' : qq{ optimize="$macro{optimize}"} ]} $paths
\%{__perl} -p -i -e 's/^Module::Build->VERSION/#Module::Build->VERSION/g' Build

./Build
END
    }
    else {
        print $spec qq{sed -i -e '/List::SomeUtils::XS/d' Makefile.PL\n}
            if( $module eq 'List::SomeUtils' );    # recursive dep

        if( $module eq 'XML::Canonical' ) {
            print( $spec
                    qq{sed -i -e 's/minor == 7/minor >= 8/g' Makefile.PL\n} );
            print( $spec
                    qq{sed -i -e 's/point == 1/point >= 0/g' Makefile.PL\n} );
            print( $spec
                    qq{sed -i -e 's/^    return/warn(\$results);\r    return/' Makefile.PL\n}
            );
        }

        print $spec <<END;
\%{__perl} Makefile.PL INSTALLDIRS=$instdir@{[$noarch ? '' : qq{ OPTIMIZE="$macro{optimize}"}]} $paths
END

        print $spec
            "\%{__perl} -pi -e 's/^\\tLD_RUN_PATH=[^\\s]+\\s*/\\t/' Makefile\n"
            if( $compat and !$noarch );

        print $spec <<END;
make \%{?_smp_mflags}
END
    }

    print $spec <<END;

\%install
rm -rf $macro{buildroot}

END

    if($usebuildpl) {
        print $spec
            "./Build install --destdir=$macro{buildroot} --create_packlist=0\n";
    }
    else {
        print $spec <<END;
make pure_install PERL_INSTALL_ROOT=$macro{buildroot} $paths

find $macro{buildroot} -type f -name .packlist -exec rm -f {} \\;
END
    }

    if( !$noarch ) {
        print $spec <<END;
find $macro{buildroot} -type f -name '*.bs' -size 0 -exec rm -f {} \\;
END
    }

    print $spec <<END;
find $macro{buildroot} -depth -type d -exec rmdir {} 2>/dev/null \\;

\%{_fixperms} $macro{buildroot}/*

END

    if( $addlicense and !grep /copying|artistic|copyright|license/i, @doc ) {
        print $spec <<END;
perldoc -t perlgpl > COPYING
perldoc -t perlartistic > Artistic

END

        push( @doc, "COPYING", "Artistic" );
    }

    print $spec <<END;
\%check@{[($compat ? ' || :' : '')]}
END

   # some modules check their manifest and can pickup debuginfo files and such
    if( !$noarch ) {
        print $spec <<'END';
cat << \EOF >> MANIFEST.SKIP
\bdebug.*.list$
\belfbins.list$
\bfilelist$
EOF
END

    }

    if($usebuildpl) {
        print $spec "./Build test\n";
    }
    else {
        ## Move to external config file
        print $spec "make test\n"
            unless(
            ( $specfile eq 'perl-Crypt-OpenSSL-VerifyX509.spec'
            )    ## FIXME MD5 cert support dropped from Fedor
            || ( $specfile eq 'perl-XML-GDOME.spec'
            )    ## FIXME libxslt changed whitespace rules
            );
    }

    print $spec <<END;

\%clean
rm -rf $macro{buildroot}

END

    print $spec <<END;
\%files
\%defattr(-,root,root,-)
\%doc @doc
END

    if($iscore) {
        if($scripts) {
            print $spec <<END;
/usr/local/share/man/man1/*
END
        }
            print $spec <<END;
/usr/local/share/man/man3/*
END
if($has_modules) {
        if($noarch) {

            if(0) {
                print $spec <<END;
/usr/share/perl5/vendor_perl/*
END
            }
            else {
                print $spec <<END;
/usr/local/share/perl5/*
END
            }
        }
        else {
             if(0) {
           print $spec <<END;
%{_libdir}/perl5/vendor_perl/*
END
            } else {
                print $spec <<END;
/usr/local/%{_lib}/perl5/*
END
            }
        }
}
        if($scripts) {
            print $spec <<END;
/usr/local/bin/*
END
        }
    }
    else {
        print $spec <<END;
\%{_mandir}/*
END
if($has_modules) {

        if($noarch) {
            print $spec <<END;
/usr/share/perl5/*
END
        }
        else {
            print $spec <<END;
%{_libdir}/perl5/*
END
        }
}
        if($scripts) {
            print $spec <<END;
\%{_bindir}/*
END
        }
    }

# BUGBUG conditional
print $spec <<END;
%{_datadir}/*
END

    print $spec <<END;

\%changelog
* $date $packager $version-$release
- Specfile autogenerated by $NAME $VERSION.

END

    $spec->close();

    build_rpm($specfile) if( $buildsrpm || ( $buildrpm && !$follow ) );

    build_n_install( $specfile, "$home/rpmbuild/" )
        if( $buildrpm && $follow );

    push( @processed,   $module );
    push( @build_order, $module );

    $build_order{$module} = $count;

    verbose("Completed loop for $file\n");
    return(@build_order);
}

sub init {
    %macro = %{ $MACROS[$macros] };

    create_repo() if( $buildrpm && $follow );

    my $rpm = which("rpm");
    $packager = $packager || `$rpm --eval '\%packager'`;

    really_chomp($packager);

    if( !$packager || $packager eq "\%packager" ) {
        croak(    "\%packager not defined in ~/.rpmmacros."
                . "  Please add or use --packager option.\n" );
    }

    if($perl_version) {
        croak(    "Unknown lerl version: $perl_version. (Known versions: "
                . join( ", ", keys %Module::CoreList::version )
                . ")" )
            unless exists $Module::CoreList::version{$perl_version};
        %corelist = %{ $Module::CoreList::version{$perl_version} };
    }
    else {
        my $rpm;

        my $repoquery = which("dnf");
        my @opts      = qw{-q repoquery --provides perl};

        if($repoquery) {
            if( $buildrpm && $follow ) {
                run_cmd( 'dnf', '--enablerepo=*', 'clean', 'all' );
                run_cmd( 'dnf', 'makecache' );
            }
        }
        else {
            if( $buildrpm && $follow ) {
## FIXME Try to get caching working for speeeed
##                run_cmd( 'yum', 'clean', 'all', '--enablerepo=*');
##                run_cmd( 'yum', 'makecache');
            }
            $repoquery = which("repoquery");
            @opts      = qw{--provides perl};
        }

        my( $std, $err ) = run_cmd( $repoquery, @opts );

        foreach my $line ( split( '\n', $std ) ) {
            really_chomp($line);

            if( $line =~ /^perl\(([^\)]+)\)(?:\s+=\s+(\S+))?\s*$/ ) {
                $corelist{$1} = defined($2) ? $2 : 0;
            }
        }
    }

    $dnf = which("dnf");

    return;
}

sub max {
    my( $x, $y ) = @_;
    verbose("max 1: $x < $y\n");

    # chop off epoch for this test
    $x =~ s/^[^:]*://g;
    $y =~ s/^[^:]*://g;
    verbose("max 2: $x < $y?\n");

    my $x1 = Perl::Version->new("$x");
    my $y1 = Perl::Version->new("$y");

    return( ( $x, $y )[ $x1 < $y1 ] );
}

sub run_cmd {
    my @cmd = @_;

    my $cmd = '';
    foreach my $arg (@cmd) {
        if($arg =~/[\s\(]/ && $arg !~ /"/) {
             $cmd .= qq{"$arg" };
        } else {
             $cmd .= qq{$arg };
        }
    }
    verbose( "\nRunning 2: $cmd");
    my $out = qx/$cmd 2>&1/;
    verbose("out: $out\n") if($out);
    verbose("\$\@: $@\n\$!: $!\n\$\?: $?\n") if($?);
    return( $out, $? );
}

sub run_cmd2 {
    verbose(  "\nRunning 3: "
            . join( ' ', @{ $_[0] } ) . " "
            . $_[1] . " "
            . join( ' ', @{ $_[2] } ) );

    my( $in, $out_and_err );
    run( $_[0], \$in, $_[1], $_[2], \$out_and_err);
#    my $cmd = join( ' ', @{ $_[0] } ) . " " . $_[1] . " " . join( ' ', @{ $_[2] } );
#    verbose(  "\nRunning 3: $cmd");
#    $out_and_err = qx/$cmd/;
    carp("Error: $?\nerr: $out_and_err\n\n\$\@: $@\n\$!: $!\n") if($? && $! ne 'Illegal seek');
    verbose("out: $out_and_err\n") if($out_and_err);

    return( $out_and_err );
}

sub print_version {
    print "$NAME version $VERSION\n";
    exit 0;
}

sub verbose {
    my $msg = shift;
    my $level = shift || 1;

    if( $verbose && $level >= $verbose ) {
        if( $verbose <= 3 ) {
            print STDERR $msg, "\n";
        }
        else {
            carp($msg);
        }
    }

    return;
}

sub fetch {
    my( $url, $file ) = @_;
    my @locations = ();

    verbose("Fetching $file from $url...");

    my $ret = system("wget --quiet --output-document=$file $url");

    verbose $? if($ret);

    return;

    my $ua = LWP::UserAgent->new( 'env_proxy' => 1 )
        || croak("LWP::UserAgent->new() failed: $!\n");
    $ua->timeout(180);
    my $request;
LOOP: $request = HTTP::Request->new( 'GET' => $url )
        || croak("HTTP::Request->new() failed: $!\n");

    my @buf = stat($file);
    $request->if_modified_since( $buf[9] ) if(@buf);

    # FIXME - Probably should do $ua->request() here and skip loop detection.
    my $response = $ua->simple_request($request)
        || croak("LWP::UserAgent->simple_request() failed: $!\n");

    push( @locations, $url );
    if( $response->code eq "301" || $response->code eq "302" ) {
        $url = $response->header('Location');
        croak(    "Redirect loop detected! "
                . join( "\n ", @locations, $url )
                . "\n" )
            if( grep { $url eq $_ } @locations );
        goto LOOP;
    }

    if( $response->is_success ) {
        my $fh = new FileHandle ">$file"
            || croak("Can't write to $file: $!\n");
        print $fh $response->content;
        $fh->close();

        my $last_modified = $response->last_modified;
        utime( time, $last_modified, $file ) if($last_modified);
    }
    elsif( $response->code eq "304" ) {
        verbose("$file is up to date.");
    }
    else {
        croak( "Failed to get $url: " . $response->status_line . "\n" );
    }

    return;
}

sub mkdir_p {
    my $dir = shift;
    my $cmd = qq{mkdir -p $dir };
    say "Runing: $cmd";
    my $res = system('mkdir', '-p', $dir);
    carp('$!: ' .  $! . ', $@: ' . $@ . ', $?: ' . $? . ", res: $res\n") if($res);
    croak("Failed to create dir: $@, $!") if($res);
    return;

    my @path = split '/', $dir;

    for( my $n = 0; $n < @path; $n++ ) {
        my $partial = "/" . join( "/", @path[ 0 .. $n ] );
        if( !-d $partial ) {
            verbose("mkdir($partial)");
            mkdir $partial || croak("mkdir($partial) failed: $!\n");
        }
    }

    return;
}

sub update_packages {
    return 1 if($updated);

    verbose("Updating $pkgdetails ...");

    mkdir_p( dirname($pkgdetails) ) if( !-d dirname($pkgdetails) );

    fetch( "$cpan/modules/" . basename($pkgdetails), $pkgdetails );

    $updated = 1;

    return;
}

sub build_rpm {
    my $spec = shift;
    my $dir  = getcwd();

    my $rpmbuild = which( "rpmbuild", "rpm" );

    verbose(
        "Building " . ( $buildrpm ? "rpms" : "source rpm" ) . " from $spec" );
    if( !-d "$spec-build" ) {
        verbose("mkdir($spec-build)");
        mkdir "$spec-build" || croak("mkdir($spec-build) failed: $!\n");
    }
    if( !-d "$spec-build" ) {
        verbose("mkdir($spec-build)");
        mkdir "$spec-build"
            || croak("mkdir($spec-build) failed: $!\n");
    }

    my ($out, $err) = run_cmd(
        $rpmbuild,
        "--define",
        "_sourcedir $dir",
        "--define",
        "_builddir $dir/$spec-build",
        "--define",
        "_srcrpmdir $dir/$spec-build",
        ( $buildrpm ? "-ba" : ( "-bs", "--nodeps" ) ),
        $spec
    );

    croak("Make failed :(") if($err);

    return;
}

sub list_files {
    my $archive = $_[0];
    my $type    = $_[1];

    if( $type eq 'tar' ) {
        return $archive->list_files();
    }
    elsif( $type eq 'zip' ) {
        return map { $_->fileName(); } $archive->members();
    }

    return;
}

sub extract {
    my $archive  = $_[0];
    my $type     = $_[1];
    my $filename = $_[2];

    if( $type eq 'tar' ) {
        return $archive->get_content($filename);
    }
    elsif( $type eq 'zip' ) {
        return $archive->contents($filename);
    }

    return;
}

sub get_description {
    my %args = @_;
    my $pm   = "";
    my( $summary, $description );

    my $path = $args{module};
    $path =~ s,::,/,g;
    my @pmfiles = ( "$args{path}/lib/$path.pod", "$args{path}/lib/$path.pm" );
    if( $args{module} =~ /::/ ) {
        my @tmp = split '/', $path;
        my $last = pop @tmp;
        push( @pmfiles,
            "$args{path}/lib/$last.pod", "$args{path}/lib/$last.pm" );
    }
    do {
        push( @pmfiles, "$args{path}/$path.pod", "$args{path}/$path.pm" );
    } while( $path =~ s,^[^/]+/,, );
    push( @pmfiles, "$args{path}/$args{module}" )
        if( $args{module} !~ /::/ );

    for my $file (@pmfiles) {
        $pm = ( grep { $_ eq $file || $_ eq "./$file" }
                list_files( $args{archive}, $args{type} ) )[0];
        last if $pm;
    }

    if($pm) {
        verbose("Trying to fetch description from $pm...");

        if( my $content = extract( $args{archive}, $args{type}, $pm ) ) {
            my $parser = Pod::Simple::TextContent->new()
                || croak("Pod::Simple::TextContent->new() failed: $!\n");
            $parser->no_whining(1);
            my $rendered = "";
            $parser->output_string( \$rendered );
            $parser->parse_string_document($content);
            if( $parser->content_seen and $rendered ) {
                if( $rendered =~ /DESCRIPTION\s+(\S.*?)\n\n/s ) {
                    $description = $1;
                }
                if( $rendered =~ /NAME\s*$args{module}\s[-\s]*(\S[^\n]*)/s ) {
                    if( $1 ne "SYNOPSIS" ) {
                        $summary = $1;
                        $summary =~ s/[.\s]+$//;
                        $summary =~ s/^(?:An?|The)\s+//i;
                        $summary = ucfirst($summary);
                    }
                }
                return( $description, $summary )
                    if( defined($description) );
            }
        }
        else {
            warn "Failed to read $pm from $args{filename}"
                . (
                $args{type} eq 'tar'
                ? ( ": " . $args{archive}->error() )
                : ""
                ) . "\n";
        }
    }

    if( my $readme = (
            sort { length($a) <=> length($b) || $a cmp $b }
                ( grep /README/i, @{ $args{files} } )
        )[0]
        )
    {
        verbose("Trying to fetch description from $readme...");

        if( my $content
            = extract( $args{archive}, $args{type}, "$args{path}/$readme" ) )
        {
            $content
                =~ s/\r//g;  # Why people use DOS text, I'll never understand.
            for my $string ( split "\n\n", $content ) {
                $string =~ s/^\n+//;
                if( ( my @tmp = split "\n", $string ) > 2
                    and $string !~ /^[#\-=]/ )
                {
                    return( $string, undef );
                }
            }
        }
        else {
            warn "Failed to read $readme from $args{filename}"
                . (
                $args{type} eq 'tar'
                ? ( ": " . $args{archive}->error() )
                : ""
                ) . "\n";
        }
    }

    return( undef, undef );
}

sub check_rpm {
    my $dep = shift;
    my $version = shift || 0;

    my $rpm = which("rpm");

    my @opts = ($rpm, '-q', "--qf='%{NAME}'", '--whatprovides', qq{"$dep"});
    my ( $out, $err ) = run_cmd2(\@opts, '|', [ 'head', '-n1' ] );

    my $package;
    $package = ( split /\n/, $out )[0] if($out);

    if( $? != 0 ) {
        verbose("backtick (rpm) failed with return value $?, $package");
        return;
    }
    elsif ($package =~ /no package provides/i) {
        return;
    }
    else {
        my $cmd
            = qq{rpm -q --provides "$package" | grep '$package = ' | sed -e 's/^.* =//g' -e 's/\-[^-]*\$//g'};
        verbose("running: $cmd");
        my $prov_ver = qx/$cmd/;
        really_chomp($prov_ver);

        # chop off epoch
        $prov_ver =~ s/^[^:]*://g  if( defined($prov_ver) );
        $prov_ver =~ s/[a-z]*$//ig if( defined($prov_ver) );
        verbose("rpm pov_version: $prov_ver\n");
        if(    !defined($prov_ver)
            || $prov_ver eq ""
            || (Perl::Version->new($version) > Perl::Version->new($prov_ver) )
            )
        {
            verbose(
                "Version required is greater than version provided: $version > $prov_ver"
            );
            return;
        }
    }

    return $package;
}

sub check_repo {
    my $dep     = shift;
    my $version = shift;

    return( $repo_cache{"$dep-$version"} )
        if( defined( $repo_cache{"$dep-$version"} ) );

    my $repoquery = which("dnf");
    my @opts = qw{repoquery --quiet --qf='%{NAME}' --latest-limit 1 --whatprovides};
    push(@opts, qq{"$dep"});
    my $opts2 = qq{repoquery --quiet --latest-limit 1 --provides};

    unless($repoquery) {
        $repoquery = which("repoquery");
        @opts = qw{--quiet  --qf='%{NAME}' --whatprovides};
        push(@opts, qq{"$dep"});
       $opts2 = qq{ --quiet  --provides};
    }

    unshift(@opts, $repoquery);

#    my ( $out, $err ) = run_cmd2(\@opts, '|', ['sort', '-r' ] );
    my ( $out, $err ) = run_cmd(@opts );
    my $package;
    $package = ( split /\n/, $out )[0] if($out);
    really_chomp($package);

    if( $? != 0 ) {
        verbose("backtick (repoquery) failed with return value $? $@");
        return;
    }

    if( !defined($package) || $package eq "" ) {

        # check if it's supplied by a source only repo
        if( my $pkg = check_src_rpm($dep) ) {
            if( exists( $dep_blacklist{$pkg} ) ) {
                verbose(qq{Skipping black listed dep $pkg});
                return;
            }
            else {
                verbose(qq{$dep suplied by $pkg in a source only repo!});
                my $srpm = download_srpm($pkg);
                build_n_install( $srpm, "$home/rpmbuild/" );
                return($pkg);
            }
        }
        else {
            verbose(qq{No package supplies $dep});
            return;
        }
    }

    # if we have versioned requires then we need to work around the
    # rpm descison that unversioned provides matches any version.
    if( $version ne "0" ) {

        # FIXME can we use runcmd2 for this?
        my $cmd
            = qq{$repoquery $opts2 "$package" | grep '$dep = ' | tail -n1 | sed -e 's/^.* =//g' -e 's/\-[^-]*\$//g'};

        verbose(qq{Running 4: '$cmd', this may take a long while.});

        my $prov_ver = qx/$cmd/;
        really_chomp($prov_ver);

        # chop off epoch
        $prov_ver =~ s/^[^:]*:\s*//g if( defined($prov_ver) );
        verbose("pov_version: '$prov_ver'\n");
        if(    !defined($prov_ver)
            || $prov_ver eq ""
            || (Perl::Version->new($version) > Perl::Version->new($prov_ver) )
            )
        {
            verbose(
                "Version required is greater than version provided: $version > $prov_ver"
            );
            return;
        }
    }

    $repo_cache{"$dep-$version"} = $package;

    return $package;
}

sub check_dep {
    my $module  = shift;
    my $version = shift;

    if(    exists( $dep_blacklist{$module} )
        || $module =~ /^Win32::/
        || $module =~ /^t::/
        || $module =~ /^[\d\.\_]+$/
        || $module =~ /^inc::/ )
    {
        verbose(qq{Skipping black-listed dep $module});
        return;
    }

    return(    check_rpm( "perl($module)", $version )
            || check_repo( "perl($module)", $version ) );
}

sub which {
    for my $bin (@_) {
        for my $path ( split /:/, $ENV{PATH} ) {
            return "$path/$bin" if -x "$path/$bin";
        }
    }
##    verbose("Cannot find " . join(" or ", @_));
    return;
}

sub check_src_rpm {
    my $pkg = shift;

    return
        if( $pkg eq 'perl(namespace::autoclean)' || $pkg =~ 'MooseX' )
        ;    # broken srpms upstream

    my @cmd
        = qw{repoquery --quiet  --qf='%{NAME} %{VERSION}' --enablerepo=* --whatprovides};

    @cmd
        = qw{/usr/bin/dnf  --quiet repoquery --qf='%{NAME}' --recent --whatprovides}
        if($dnf);

        push(@cmd, "'$pkg'");

#    verbose("check_src_rpm running:  $cmd");
#    my $result = qx/$cmd/;
    my( $out, $err ) = run_cmd(@cmd);
    my $result;
    $result = ( split /\n/, $out )[0] if($out);
    really_chomp($result);
    verbose("result: $result");
    my( $rpm, $ver );
    ( $rpm, $ver ) = split( / /, $result ) if($result);
    return($rpm);
}

sub download_srpm {
    my $pkg = shift;

    return
        if( $pkg eq 'perl(namespace::autoclean)' || $pkg =~ 'MooseX' )
        ;    # broken srpm upstream

    my $dir = "$wd_path/$pkg";
    $dir =~ s/perl\((.*)\)/perl-$1/;
    $dir =~ s/::/-/g;
    $dir =~ s/[ >=<]//g;
    mkdir_p($dir) if( !-d ($dir) );

    if ($dnf) {
        run_cmd(
            $dnf,            'download',
            '--quiet',       '--nogpgcheck',
            '--source',      '--enablerepo=*',
            '--downloaddir', $dir,
            $pkg
        );
    }
    else {
        run_cmd( 'yumdownloader', '--quiet', '--nogpgcheck', '--source',
            '--enablerepo=*', '--destdir', $dir, $pkg );
    }


    my @files = glob("$dir/*.src.rpm");
    return( $files[0] );
}

sub rebuild_srpm {
    my $srpm = shift;
    run_cmd( 'rpmbuild', '--rebuild', $srpm );
    return;
}

sub build_n_install {
    my $pkg  = shift;
    my $dirs = shift;

## FIXME there is no version handling here
    my $package = $pkg;
    $package =~ s/perl\((.*)\).*/$1/;
##    $package =~ s/::/-/g;

    verbose("Building $package");

    if( grep { $_ eq $package } @processed ) {
        verbose("Skipping $package already processed");
    }
    else {

        install_deps($pkg);
        if( grep { $_ eq $package } @processed ) {
            verbose("Skipping $package processed by a dep");
            return;
        }

        my $name;
        if( $pkg =~ m{([^/]*)\.spec} ) {
            $name = $1;
            build_rpm($pkg);
        }
        else {
            my( $out, $err )
                = run_cmd( 'rpm', '-q', '--qf', '%{NAME}', '-p', $pkg );
            $name = $out;
            rebuild_srpm($pkg);
        }

        install_pkg( $dirs, $name );

        push( @processed, $package );
    }
    return;
}

sub install_deps {
    my $file = shift;

    my( $std, $err, @missing );

    verbose("Installing deps for $file");

    if($dnf) {
        ( $std, $err ) = run_cmd( qw{dnf -y builddep }, $file );
    }
    else {
        ( $std, $err ) = run_cmd( 'yum-builddep', '-t', '-y', $file );

    }
    verbose("std: $std\n\nerr: $err");
    # &^%&%$ dnf switched this to std err
    foreach( split( "\n", $std. "\n". $err) ) {
        push( @missing, $_ )
            if($_ =~ /No Package found for/i
            || $_ =~ /No matching package to install/i );
    }

    foreach my $dep (@missing) {
        really_chomp($dep);
        $dep =~ s/Error: No Package found for //i;
        $dep =~ s/No matching package to install: //i;
        $dep =~ s/-devel//;
        $dep =~ s/'//g;

        my $package = $dep;
        $package =~ s/perl\((.*)\).*/$1/;
        $package =~ s/::/-/g;

        unless( grep { $_ eq $package } @processed ) {
            verbose("Building missing dep $dep for $file");
            my $srpm;
            eval { $srpm = download_srpm($dep); };
            if($srpm) {
                build_n_install( $srpm, "/$home/rpmbuild/" );
            }
            else {
                my $spec = "perl-$package.spec";
                process_module($package);
            }
            verbose("Completed missing dep $package for $file\n");
            push( @processed, $package );
        }
    }

    ## BUGBUG yum-buidldep stopped installing found packages if any where missing, maybe someone broek --tolerant?
    if(@missing) {
    if($dnf) {
        ( $std, $err ) = run_cmd( qw{dnf -y builddep }, $file );
    }
    else {
        ( $std, $err ) = run_cmd( 'yum-builddep', '-t', '-y', $file );

    }
    }

    return;
}

sub create_repo {
    unless( -d "$repo_path" ) {
        run_cmd( 'mkdir',      '-p', "$repo_path" );
        run_cmd( 'createrepo', '-v', "$repo_path" );
    }
    unless( -d "$repo_path/../SRPMS" ) {
        run_cmd( 'mkdir', '-p', "$repo_path/../SRPMS" );
    }

    return;
}

sub install_pkg {
    my $paths = shift;
    my $name  = shift;

    my $cmd = 'yum';
    $cmd = 'dnf' if($dnf);

    run_cmd2(
        [ 'find', $paths, '-name', "$name*", '-type', 'f' ],
        '|',
        [   'xargs', '--no-run-if-empty', 'cp', '-v', '-a', '-t',
            "$repo_path"
        ]
    );
    run_cmd( 'createrepo', '-v', '--update', "$repo_path" );
    run_cmd( $cmd, '--disablerepo=*',
        '--enablerepo', 'cpanspec', 'clean', 'expire-cache' );

    my( $res, $err );

    if($dnf) {
        run_cmd(  $cmd, 'makecache', '--repo', 'cpanspec');
    } else {
         run_cmd(  $cmd, 'makecache');       
    }

    croak($err) if( $err );

    ( $res, $err ) = run_cmd( $cmd, '-y', 'install', "$name\\*" );

    croak($err) if( $err && ( $err !~ /Error: Nothing to do/ms ) );

    return;
}

sub get_provides {
    my %args = @_;
    my %provides;
    verbose( "Checking provides for " . $args{module} );

    foreach my $file ( @{ $args{files} } ) {
        next if( $file !~ m{\.pm$} || $file =~ m{^inc/} );

        if( $args{type} eq 'zip' ) {
            $args{archive}->extractMember( "$args{path}/$file", 'tmp.pm' );
        }
        else {
            $args{archive}->extract_file( "$args{path}/$file", 'tmp.pm' );
        }
        verbose(qx{/usr/lib/rpm/perl.prov tmp.pm});
        foreach my $pkg (qx{/usr/lib/rpm/perl.prov tmp.pm}) {
            really_chomp($pkg);
            $pkg =~ s/^perl\(//;
            $pkg =~ s/\).*$//;    # FIXME grab version?
            if( $pkg
                !~ /^(?:$args{module}|Module::AutoInstall|Module::Install.*|Win32.*)$/
                )
            {
                $provides{$pkg} = $pkg;
                verbose( "Adding $pkg as a provide of " . $args{module} );
            }
        }
        unlink('tmp.pm');
    }
    return(%provides);

}

sub really_chomp {
    return unless($_[0]);
    chomp( $_[0] );
    $_[0] =~ s/\R$//g;

    return;
}

