#!/usr/bin/perl
#
# cpanspec - Generate a spec file for a CPAN module
#
# Copyright (C) 2004-2011 Steven Pritchard <steve@kspei.com>
# This program is free software; you can redistribute it
# and/or modify it under the same terms as Perl itself.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# $Id: cpanspec,v 1.68 2009/01/22 01:48:06 stevenpritchard Exp $

use strict;
use warnings;
use 5.10.1;
use bignum;
$! = 1;

my $NAME    = "cpanspec";
my $VERSION = '2.0_2';

=head1 NAME

cpanspec - Generate a spec file for a CPAN module

cpanget - Download a CPAN module

=head1 SYNOPSIS

cpanspec [options] [module [...]]

cpanget [options] [module [...]]

 Options:
   --help       -h      Help message
   --old        -o      Be more compatible with old RHL/FC releases
   --perl-version   -P  Minimum perl version to support
   --license    -l      Include generated license texts if absent in source
   --noprefix   -n      Don't add perl- prefix to package name
   --force      -f      Force overwriting existing spec
   --packager   -p      Name and email address of packager (for changelog)
   --release    -r      Release of package (defaults to 1)
   --epoch      -e      Epoch of package
   --disttag    -d      Disttag (defaults to %{?dist})
   --srpm       -s      Build a source RPM
   --build      -b      Build source and binary RPMs
   --cpan       -c      CPAN mirror URL
   --verbose    -v      Be more verbose, more v's for more messages
   --prefer-macros  -m  Prefer macros over environment variables in the spec
   --download-only  -D  Only download the tarball from CPAN

 Long options:
   --follow             Process build dependencies
   --filter-requires    Specify Requires to remove
   --filter-provides    Specify Provides to remove
   --add-requires       Add Requires for this item
   --add-provides       Add Provides for this item
   --add-buildrequires  Add BuildRequires for this item
   --version            Print the version number and exit

The modules specified on the command line can be either filenames of tarballs,
or module names as downloadable from CPAN.

=head1 EXAMPLES

cpanspec Linux::Prctl

cpanspec ~/downloads/Acme-MetaSyntactic-0.99.tar.gz

cpanget Module::Build

=head1 DESCRIPTION

B<cpanspec> will generate a spec file to build a RPM from a CPAN-style
Perl module distribution.

B<cpanget> will download the tarball for a module from CPAN. This
implies --download-only and ignores most other options.

=head1 OPTIONS

=over 4

=item B<-h>, B<--help>

Print a brief help message and exit.

=item B<-o>, B<--old>

Be more compatible with old RHL/FC releases.  With this option enabled,
the generated spec file

=over 4

=item *

Defines perl_vendorlib or perl_vendorarch.

=item *

Includes explicit dependencies for core Perl modules.

=item *

Uses C<%check || :> instead of just C<%check>.

=item *

Includes a hack to remove LD_RUN_PATH from Makefile.

=back

=item B<-P>, B<--perl-version>

Include explicit dependencies for core modules when newer versions are
required than shipped with the specified version.

=item B<-l>, B<--license>

Generate COPYING and Artistic license texts if the source doesn't seem
to include them.

=item B<-n>, B<--noprefix>

Don't add I<perl-> prefix to the name of the package.  This is useful
for perl-based applications (such as this one), so that the name of
the RPM is simply B<cpanspec> instead of B<perl-cpanspec>.

=item B<-f>, B<--force>

Force overwriting an existing spec file.  Normally B<cpanspec> will
refuse to overwrite an existing spec file for safety.  This option
removes that safety check.  Please use with caution.

=item B<-S>, B<--stdout>

Write the generated spec file to stdout instead of a file.

=item B<-p>, B<--packager>

The name and email address of the packager.  Overrides the C<%packager>
macro in C<~/.rpmmacros>.

=item B<-r>, B<--release>

The release number of the package.  Defaults to 1.

=item B<-e>, B<--epoch>

The epoch number of the package.  By default, this is undefined, so
no epoch will be used in the generated spec.

=item B<-d>, B<--disttag>

Disttag (a string to append to the release number), used to
differentiate builds for various releases.  Defaults to the
semi-standard (for Fedora) string C<%{?dist}>.

=item B<-D>, B<--download-only>

Only download the upstream tarball, do not generate a specfile. Most
other options are ignored as they are only relevant when creating a
specfile or building a package.

=item B<-s>, B<--srpm>

Build a source RPM from the generated spec file.

=item B<-b>, B<--build>

Build source and binary RPMs from the generated spec file.
B<Please be aware that this is likely to fail!>  Even if it succeeds,
the generated RPM will almost certainly need some work to make
rpmlint happy.

=item B<-c>, B<--cpan>

The URL to a CPAN mirror.  If not specified with this option or the
B<CPAN> environment variable, defaults to L<http://www.cpan.org/>.

=item B<-v>, B<--verbose>

Be more verbose. Can be specified multiple times.

=item B<-m>, B<--prefer-macros>

Prefer the macro form of common spec constructs over the environment variable
form (e.g. %{buildroot} V $RPM_BUILD_ROOT).

=item B<--follow>

Add build dependencies to the list of modules to process.

=item B<--filter-requires>

Specify Requires to remove.

=item B<--filter-provides>

Specify Provides to remove.

=item B<--add-requires>

Add Requires for this item.

=item B<--add-provides>

Add Provides for this item.

=item B<--add-buildrequires>

Add BuildRequires for this item.

=item B<--version>

Print the version number and exit.

=back

=head1 AUTHOR

Steven Pritchard <steve@kspei.com>

=head1 SEE ALSO

L<perl(1)>, L<cpan2rpm(1)>, L<cpanflute2(1)>

=cut

use Carp qw(carp croak longmess);

use Archive::Tar;
use Archive::Zip qw(:ERROR_CODES);
use CPAN::Meta;
use File::Basename;
use File::pushd;
use FileHandle;
use Getopt::Long;
use IO::Uncompress::Bunzip2;
use IPC::Run qw( run );
use LWP::UserAgent;
use Module::CoreList;
use POSIX;
use Parse::CPAN::Packages;
use Perl::Version;
use Pod::Simple::TextContent;
use Pod::Usage;
use Symbol 'gensym';
use Text::Autoformat;
use YAML qw(Load);
use locale;

# Apparently gets pulled in by another module.
#use Cwd;

my %opt;

my $help         = 0;
my $compat       = 0;
my $perl_version = $];
my $addlicense   = 0;
my $noprefix     = 0;
my $force        = 0;
my $stdout       = 0;
my $packager;
my $release = 1;
## FIXME hmm if a package fails because the current RPM isn't new enough then we have to check the epoch
### Also if packages use variable length versions we need to set epochs ... e.g. 5.123 < 5.13 in cpan but > in rpm
my $epoch         = 4;
my $disttag       = '%{?dist}';
my $download_only = (basename($0) eq "cpanget") ? 1 : 0;
my $buildsrpm     = 0;
my $buildrpm      = 0;
my $verbose       = 0;
my $follow        = 0;
my $macros        = 0;
my $source;
my $cpan = $ENV{'CPAN'} || "http://www.cpan.org";

my $home = $ENV{'HOME'} || (getpwuid($<))[7];
croak("Can't locate home directory.  Please define \$HOME.\n")
    if (!defined($home));

my $pkgdetails = "$home/.cpan/sources/modules/02packages.details.txt.gz";
my $updated    = 0;

my $packages;
my %repo_cache;
my %corelist;

my @filter_requires;
my @filter_provides;
my @add_requires;
my @add_provides;
my @add_buildrequires;

# env. vars and their macro analogues
my @MACROS = (

    # 0 is for the full expansions....
    {   'optimize'  => '$RPM_OPT_FLAGS',
        'buildroot' => '$RPM_BUILD_ROOT',
    },

    # 1 is for the macros.
    {   'optimize'  => '%{optflags}',
        'buildroot' => '%{buildroot}',
    },
);

# this is set after the parameters are passed
my %macro;

my %dep_blacklist = (
    '5'                                      => 1,
    'BaseClass'                              => 1,    # Common test class shipped by ourselves
    'Blarg'                                  => 1,
    'CPAN::Config'                           => 1,    # FIXME how is this getting detected?
    'Config'                                 => 1,
    'DBD::Oracle'                            => 1,
    'DBI::db'                                => 1,    # part of DBD::Oracle
    'Dist::CheckConflicts'                   => 1,    # DistZilla.hate++
    'Foo::Bar'                               => 1,
    'Language::Expr::Interpreter::VarEnumer' => 1,
    'MacPerl'                                => 1,
    'Module::Install::AuthorRequires'        => 1,
    'Module::Install::AuthorTests'           => 1,
    'MyApp'                                  => 1,
    'MyModuleBuilder'                        => 1,
    'MyTest'                                 => 1,
    'Term::Choose::Win32'                    => 1,
    'Test::DependentModules'                 => 1,
    'Test::Kwalitee'                         => 1,    # almost never a real dep
    'Test::Pod'                              => 1,    # almost never a real dep
    'Test::Run::Builder'                     => 1,    # FIXME things in inc should be ignored
    'TestServer'                             => 1,    # Likewise
    'VMS::Filespec'                          => 1,
    'Win32'                                  => 1,    # We're not on win32
    'Win32::API'                             => 1,    # We're not on win32
    'Win32::Console'                         => 1,
    'Win32::Console::ANSI'                   => 1,
    'Win32::Process'                         => 1,    # We're not on win32
    'Win32::TieRegistry'                     => 1,    # We're not on win32
    'argument'                               => 1,    # OOTools
    'base'                                   => 1,
    'completion'                             => 1,
    'constant'                               => 1,
    'indirect'                               => 1,
    'lib'                                    => 1,
    'of'                                     => 1,    # o_O
    'strict'                                 => 1,
    'this'                                   => 1,
    'warnings'                               => 1,
);

# FIXME deal with modules with incompatible versioning histories.
# Is there a better way to get rpm to grok 5.562 < 5.57 ?
# $ rpmdev-vercmp 5.562 5.57
# 5.562 > 5.57
# $ rpmdev-vercmp 0:5.562 1:5.57
# 0:5.562 < 1:5.57
#
# perl -e 'use Perl::Version; my $v1 = Perl::Version->new( q{5.562} ); my $v2 = Perl::Version->new( q{5.57} ); print ($v1->vcmp( $v2 ) > 0 ? "yes" : "no"), "\n";'
# yes

my %min_versions = ('Exporter' => '5.57',);

# Set locale to en_US.UTF8 so that dates in changelog will be correct
# if using another locale. Also ensures writing out UTF8. (Thanks to
# Roy-Magne Mo for pointing out the problem and providing a solution.)
setlocale(LC_ALL, "en_US.UTF-8");

my $wd_path = '/cpanspec';

GetOptions(
    'help|h'              => \$help,
    'old|o'               => \$compat,
    'perl-version|P=s'    => \$perl_version,
    'license|l'           => \$addlicense,
    'noprefix|n'          => \$noprefix,
    'force|f'             => \$force,
    'stdout|S'            => \$stdout,
    'packager|p=s'        => \$packager,
    'release|r=i'         => \$release,
    'epoch|e=i'           => \$epoch,
    'disttag|d=s'         => \$disttag,
    'download-only|D'     => \$download_only,
    'srpm|s'              => \$buildsrpm,
    'build|b'             => \$buildrpm,
    'cpan|c=s'            => \$cpan,
    'verbose|v+'          => \$verbose,
    'follow'              => \$follow,
    'filter-requires=s'   => \@filter_requires,
    'filter-provides=s'   => \@filter_provides,
    'add-requires=s'      => \@add_requires,
    'add-provides=s'      => \@add_provides,
    'add-buildrequires=s' => \@add_buildrequires,
    'version'             => \&print_version,
    'prefer-macros|m'     => \$macros,
    'path=s'              => \$wd_path,
) || pod2usage({ -exitval => 1, -verbose => 0 });

pod2usage({ -exitval => 0, -verbose => 1 }) if ($help);
pod2usage({ -exitval => 1, -verbose => 0 }) if (!@ARGV);

my $repo_path = $wd_path . '/repo';
my $prefix    = $noprefix ? "" : "perl-";
my @args      = @ARGV;
my @processed = ();
my $dnf;
my %created_specfiles;

init();
update_packages();

$packages = Parse::CPAN::Packages->new($pkgdetails)
    if (!defined($packages));
croak("Parse::CPAN::Packages->new() failed: $!\n")
    if (!defined($packages));

my @build_order;

for my $mod (@args) {
    if ($buildrpm && $follow) {
        if ($mod =~ /src\.rpm$/) {
            build_n_install($mod, "$home/rpmbuild/");
        }
        else {
            $mod =~ s/::/-/g;
            my $spec = "$prefix$mod.spec";

            if (-f $spec) {
                build_n_install($spec, "$spec-build/");
            }
            else {
                # check if it's a non-perl dep!
                if (my $pkg = check_src_rpm($mod)) {
                    my $srpm = download_srpm($pkg);
                    build_n_install($srpm, "$home/rpmbuild/");
                }
                else {
                    process_module($mod);
                }
            }
        }
    }
    else {
        process_module($mod,);
    }
}

if ($buildrpm && $follow) {

    run_cmd2(
        [   'find',  "$wd_path", '-name', "*.src.rpm",
            '-type', 'f',        '-not',  '-path',
            "$wd_path/SRPMS/*"
        ],
        '|',
        [ 'xargs', '--no-run-if-empty', 'cp', '-v', '-f', '-a', '-t', "$wd_path/SRPMS" ]
    );

    run_cmd2([ 'find', "/root/rpmbuild", '-name', "*.src.rpm", '-type', 'f' ],
        '|', [ 'xargs', '--no-run-if-empty', 'cp', '-v', '-f', '-a', '-t', "$wd_path/SRPMS" ]);
}

if (@build_order) {
    my $file_name = "build_order.txt";
    my $order     = FileHandle->new(">> $file_name");
    croak("Failed to open $file_name: $!\n") if (!$order);
    print $order "\n" . join("\n", @build_order);
    $order->close();
}

exit;

###################################################
#

sub process_module {
    my ($file) = @_;

    my %build_order;
    my $count = -1;
    my (@build_reqs, @add_reqs, @filter_reqs);
    my $asked_for = $file;

    my ($name, $version, $type);
    $count++;
    verbose(longmess("Starting loop for $file"));
    if ($file =~ /^(?:.*\/)?(.*)-(?:v\.?)?([^-]+)\.(tar)\.(?:gz|bz2)$/) {
        $name    = $1;
        $version = $2;
        $type    = $3;
    }
    elsif ($file =~ /^(?:.*\/)?(.*)-(?:v\.?)?([^-]+)\.tgz$/) {
        $name    = $1;
        $version = $2;
        $type    = 'tar';
    }
    elsif ($file =~ /^(?:.*\/)?(.*)-(?:v\.?)?([^-]+)\.(zip)$/) {
        $name    = $1;
        $version = $2;
        $type    = $3;
    }
    else {
        # keep things happy if we get "Foo-Bar" instead of "Foo::Bar"
        $file =~ s/-/::/g;
        $asked_for = $file;

        # Look up $file in 02packages.details.txt.
        my ($m, $d);
        if ($m = $packages->package($file) and $d = $m->distribution()) {
            my $nist = $d->dist();
            $nist =~ s/-/::/g;
            verbose("Is $nist provided by another package?");
            if (grep { $_ eq $nist } @processed) {
                carp("Skipping $file, provided by another dep\n");
                return;
            }
            $source = $cpan . "/authors/id/" . $d->prefix();
            $file   = "$wd_path/" . basename($d->filename());
            fetch($source, $file);
            return if ($download_only);

            $name    = $d->dist();
            $version = $d->version();
            $version =~ s/^v\.?//;
            if ($file =~ /\.(tar)\.gz$/) {
                $type = $1;
            }
            elsif ($file =~ /\.tgz$/) {
                $type = 'tar';
            }
            elsif ($file =~ /\.(zip)$/) {
                $type = $1;
            }
            else {
                carp "Failed to parse '$file', skipping...\n";
                next;
            }
        }
        else {
            carp "Failed to parse '$file' or find a module by that name, skipping...\n";
            return;
        }
    }

    my $module = $name;
    $module =~ s/-/::/g;

    croak("you can't update perl using cpanspec!") if ($module eq 'perl');

    my %mod_hash = (
        name     => $name,
        module   => $module,
        file     => $file,
        version  => $version,
        type     => $type,
        specfile => "$prefix$name.spec",
    );

    ## FIXME this really needs to check everything in the module ...
    ## As in if anything the module provides is a Core feature, then the
    ## whole package must be treated that way
    $mod_hash{iscore}
        = exists($corelist{$module})
        || defined($corelist{$name})
        || defined($corelist{$asked_for});

    verbose(
        "$module or $name is supplied by core perl, moving package content to vendor paths to avoid conflicts."
    ) if ($mod_hash{iscore});

    _module_details(\%mod_hash);

    _write_spec(\%mod_hash);

    build_rpm($mod_hash{specfile}) if ($buildsrpm || ($buildrpm && !$follow));

    build_n_install($mod_hash{specfile}, "$home/rpmbuild/")
        if ($buildrpm && $follow);

    push(@processed,   $module);
    push(@build_order, "$prefix$name.spec");

    $build_order{$module} = $count;

    verbose("Completed loop for $file\n");

    return;
}

sub _module_details {
    my ($mod_hash) = @_;

    my $archive;
    my $path;
    my $type = $mod_hash->{type};
    my $file = $mod_hash->{file};

    my $name    = $mod_hash->{name};
    my $version = $mod_hash->{version};
    my $module  = $mod_hash->{module};

    if ($type eq 'tar') {
        my $f = $file;
        if ($file =~ /\.bz2$/) {
            $f = IO::Uncompress::Bunzip2->new($file);
            if (!defined($f)) {
                carp "IO::Uncompress::Bunzip2->new() failed on $file: $!\n";
                next;
            }
        }
        $archive = Archive::Tar->new($f, 1)
            || croak("Archive::Tar->new() failed: $!\n");
    }
    elsif ($type eq 'zip') {
        $archive = Archive::Zip->new()
            || croak("Archive::Zip->new() failed: $!\n");
        croak("Read error on $file\n")
            unless ($archive->read($file) == AZ_OK);
    }

    for my $entry (list_files($archive, $type)) {
        next if ($type eq 'tar' and $entry eq 'pax_global_header');

        if ($entry !~ /^(?:.\/)?($name(?:-(?:v\.?)?$version)?)(?:\/|$)/) {
            carp "BOGUS PATH DETECTED: $entry\n";
            next;
        }
        elsif (!defined($path)) {
            $path = $1;
        }

        $entry =~ s,^(?:.\/)?$name(?:-(?:v\.?)?$version)?/,,;

        next if (!$entry);

        $mod_hash->{uses_autoinstall} = 1 if ($entry =~ /AutoInstall.pm/);

        next
            if ($entry =~ m{^(?:eg|tools|inc)/}
            || $entry =~ m{Conflicts.pm$});

        push(@{ $mod_hash->{files} }, $entry);
    }

    $source = $source
        || "http://www.cpan.org/modules/by-module/"
        . (
        $module =~ /::/
        ? (split "::", $module)[0]
        : (split "-", $name)[0]
        )
        . "/"
        . basename($file);
    $source =~ s/$version/\%{version}/;

    my %my_provides = get_provides(
        archive => $archive,
        type    => $type,
        module  => $module,
        files   => $mod_hash->{files},
        path    => $path,
    );

    # To much crap in the world, just match know docs
    @{ $mod_hash->{doc} } = sort { $a cmp $b } grep {
               $_ =~ "^README.*"
            or $_ eq "doc"
            or $_ eq "docs"
            or $_ eq "COPYING"
            or $_ eq "LICENSE"
            or $_ =~ /^Changes$/i
            or $_ =~ /^TODO$/i
    } @{ $mod_hash->{files} };

    # FIXME Ignore test files, we only care if the module compiles stuff to ship
    $mod_hash->{noarch} = !grep /(?!^t\/.*)\.(c|h|xs|inl)$/i, @{ $mod_hash->{files} };

    my $my_builder = 'Module::Build';
    $mod_hash->{usebuildpl} = 0;

    $mod_hash->{scripts} = (grep /^(?:bin|scripts?|tools)\//, @{ $mod_hash->{files} });
    my $makecontent;

    if (grep /^Build\.PL$/, @{ $mod_hash->{files} }) {
        $makecontent = extract($archive, $type, "$path/Build.PL");
        if ($makecontent =~ /use (Module::Build::[^\s;]*)/) {
            $my_builder = $1;
        }

        $mod_hash->{usebuildpl} = 1;
    }
    elsif (grep /^Makefile\.PL$/, @{ $mod_hash->{files} }) {
        $makecontent = extract($archive, $type, "$path/Makefile.PL");
    }

    # FIXME only works for most simple case
    if ($makecontent =~ /'?LIBS'?\s*=>\s*\[([^\]]*)\]/sm) {
##        verbose($makecontent);
        foreach my $lib (split(/\s+/, $1)) {
            verbose("Found lib $lib ...");
            $lib =~ s/-l//i;
            $lib =~ s/['"]//g;
            $lib =~ s/[;,]$//;
            next if ($lib eq 'm');

            if (!$lib || $lib !~ /\S/) {
                $makecontent =~ /'?LIBS'?\s*=>\s*\[(.*)\]/s;
                verbose("Empty lib found for $module: $1");
                next;
            }

            # FIXME blows up on variables :(
            if ($lib =~ /\$([\w-]*)/) {
                my $test = $1;
                verbose("lib: $lib");

                # Dirty dirty hack to try and find out what commands are being used for libs
                if ($makecontent =~ /$test\s*=[\W]*([-\w]*)/) {
                    my $cmd = $1;
                    $test = check_repo("*/$cmd", 0) || check_rpm("*/$cmd");
                    unless ($test) {
                        verbose("Can't work out what provides: $cmd");
                        next;
                    }
                    really_chomp($test);
                    $lib = $test;
                    if ($test =~ /^(.*)-devel/) {
                        $lib = $1;
                    }
                    $lib =~ s/mingw\d*-//;    # chop off cross platform bit if we got it
                    verbose("found $lib for $cmd");
                }
                else {
                    verbose("Can't handle LIBS with variables in them :(");
                    next;
                }
            }
            else {
                my $pkg
                    = (check_rpm("$lib", 0) || check_repo("$lib", 0));
                $pkg = (check_rpm("pkgconfig($lib)", 0) || check_repo("pkgconfig($lib)", 0))
                    unless ($pkg);
                $pkg = (check_rpm("pkgconfig(lib$lib)", 0) || check_repo("pkgconfig(lib$lib)", 0))
                    unless ($pkg);
                if ($pkg) {
                    $pkg =~ s/-devel//;
                    verbose("found $pkg for $lib");
                    $lib = $pkg;
                }
                else {
                    verbose("Could not work out what provides $lib");
                }
            }

            carp("no idea what to do with $lib, adding it to requires anyway ...");
            $mod_hash->{requires}->{$lib} = 0;
            $mod_hash->{build_requires}->{"$lib-devel"} = 0;
        }
    }

    # FIXME only works for most simple case
    if ($makecontent =~ /ExtUtils::PkgConfig->find\(['"](.*)['"]\)/) {
        my $dep = $1;
        my $cmd
            = q{repoquery --quiet  -s --whatprovides }
            . $dep
            . q{.\* | head -n1 | perl -p -e 's/-[^-]*.src.rpm//g' | xargs repoquery --quiet --qf "%{NAME}"};

        $cmd
            = q{dnf  --quiet repoquery -s --whatprovides }
            . $dep
            . q{.\* | head -n1 | perl -p -e 's/-[^-]*.src.rpm//g' | xargs dnf --quiet repoquery --qf "%{NAME}"}
            if (which("dnf"));
        verbose("Running 1: $cmd");
        my $lib = qx/$cmd/;
        verbose("lib: $lib");
        really_chomp($lib);

        $mod_hash->{requires}->{$lib} = 0;
        $mod_hash->{build_requires}->{"$lib-devel"} = 0;
    }

    # BUGBUG these are bugs and should be sent to the module author
    if ($module eq 'Data::Format::Pretty') {
        $mod_hash->{requires_perl}->{'Module::Load'}         = 0;
        $mod_hash->{requires_perl}->{'Module::Loaded'}       = 0;
        $mod_hash->{build_requires_perl}->{'Module::Load'}   = 0;
        $mod_hash->{build_requires_perl}->{'Module::Loaded'} = 0;
    }

    if (grep /^META\.json$/, @{ $mod_hash->{files} }) {
        $mod_hash->{meta}
            = CPAN::Meta->load_json_string(extract($archive, $type, "$path/META.json"));
    }
    elsif (grep /^META\.yml$/, @{ $mod_hash->{files} }) {
        $mod_hash->{meta}
            = CPAN::Meta->load_yaml_string(extract($archive, $type, "$path/META.yml"));
    }

    croak "no meta!" unless ($mod_hash->{meta});

    if ($mod_hash->{meta}->{dynamic_config}) {
        _generate_mymeta($mod_hash, $archive);
    }

    _proc_meta($mod_hash);

    my $descr = $mod_hash->{meta}->description;
    unless ($descr) {
        $descr = "$module Perl module";
    }

    if ($mod_hash->{iscore}) {
        $descr .= "\n\nThis package overrides the core perl package.";
    }

    $mod_hash->{description} = autoformat($descr);

    $mod_hash->{summary} = $mod_hash->{meta}->abstract;

    return;
}

sub _generate_mymeta {
    my ($mod_hash, $archive) = @_;

    my $name    = $mod_hash->{name};
    my $version = $mod_hash->{version};

    my $dir = tempd();
    $archive->extract();
    my $dir2 = pushd("$name-$version");

    if ($mod_hash->{usebuildpl}) {
        run_cmd('perl',    'Build.PL');
        run_cmd('./Build', 'dist');
    }
    else {
        run_cmd('perl', 'Makefile.PL');
        run_cmd('make', 'distmeta');
    }

    if (-f 'MYMETA.json') {
        $mod_hash->{meta} = CPAN::Meta->load_file('MYMETA.json');
    }
    elsif (-f 'MYMETA.yml') {
        $mod_hash->{meta} = CPAN::Meta->load_file('MYMETA.yml');
    }
    else {
        if (-f "$name-$version/META.yml") {
            $mod_hash->{meta} = CPAN::Meta->load_file("$name-$version/META.yml");
        }
    }

    return;
}

sub _write_spec {
    my ($mod_hash) = @_;

    my $specfile = $mod_hash->{specfile};
    my $name     = $mod_hash->{name};

    croak("already wrote $specfile")
        if (exists($created_specfiles{$specfile}));

    $created_specfiles{$specfile} = 1;
    verbose("Writing $specfile...");
    verbose(getcwd() . "/$specfile");
    my $spec;
    if ($stdout) {
        $spec = *STDOUT;
    }
    elsif ($force) {
        rename($specfile, "$specfile~") if (-e $specfile);
        $spec = new FileHandle ">$specfile";
    }
    else {
        $spec = new FileHandle "$specfile", O_WRONLY | O_CREAT | O_EXCL;
    }

    if (!$spec) {
        croak "Failed to create $specfile: $!\n";
    }

    print $spec <<END;
Name:           $prefix$name
Version:        $mod_hash->{version}
Release:        $release$disttag
END

    print $spec "Epoch:          $epoch\n" if (defined($epoch));

    _proc_lic($mod_hash);

    my $url = "http://search.cpan.org/dist/$name/";

    print $spec <<END;
Summary:        $mod_hash->{summary}
License:        $mod_hash->{license}
Group:          Development/Libraries
URL:            $url
Source0:        $source
BuildRoot:      \%{_tmppath}/\%{name}-\%{version}-\%{release}-root-\%(\%{__id_u} -n)
AutoReq:        no
END

    printf $spec "%-16s%s\n", "BuildArch:", "noarch" if ($mod_hash->{noarch});

    for my $dep (sort keys(%{ $mod_hash->{build_requires} })) {
        printf $spec "%-16s%s >= %s\n", "BuildRequires:", $dep,
            $mod_hash->{build_requires}->{$dep};
    }

    for my $dep (sort keys(%{ $mod_hash->{build_requires_perl} })) {
        printf $spec "%-16sperl(%s) >= %s\n", "BuildRequires:", $dep,
            $mod_hash->{build_requires_perl}->{$dep};
    }

    for my $dep (sort keys(%{ $mod_hash->{requires} })) {
        printf $spec "%-16s%s >= %s\n", "Requires:", $dep, $mod_hash->{requires}->{$dep};
    }

    for my $dep (sort keys(%{ $mod_hash->{requires_perl} })) {
        printf $spec "%-16sperl(%s) >= %s\n", "Requires:", $dep,
            $mod_hash->{requires_perl}->{$dep};
    }

    print $spec <<END;

\%description
$mod_hash->{description}

\%prep
\%setup -q -n $name-$mod_hash->{version}
END

    if (grep { $_ eq "pm_to_blib" } @{ $mod_hash->{files} }) {
        print $spec <<'END';

rm -f pm_to_blib
END
    }

    print $spec <<END;

\%build
END

    if ($mod_hash->{uses_autoinstall}) {
        print $spec <<END;
export PERL_AUTOINSTALL="--skipdeps"
END
    }

    # https://fedoraproject.org/wiki/Perl/Draft:INC_directories
    #    my $instdir = $iscore ? 'vendor' : $usebuildpl ? 'core' : 'perl';
    my $instdir = $mod_hash->{iscore} ? 'site' : $mod_hash->{usebuildpl} ? 'vendor' : 'perl';
    my $paths
        = qq{INSTALLVENDORMAN3DIR=$macro{buildroot}%{perlvendorman3} INSTALLVENDORMAN1DIR=$macro{buildroot}%{perlvendorman1}};

    # FIXME probably should make this behavior optional
    # For packages that override core packages
    $paths
        = "INSTALLSITEMAN3DIR=/usr/local/share/man/man3 INSTALLSITEMAN1DIR=/usr/local/share/man/man1 INSTALLSITEBIN=/usr/local/bin  INSTALLVENDORARCH=/usr/local/%{_lib}/perl5/"
        if ($mod_hash->{iscore});

    # BUGBUG breaks packages on rhel6...
##    $paths = "";

    if ($mod_hash->{usebuildpl}) {
        $paths = "";    #lc($paths); ## Confilcts with Module::Build::Simple??

        print $spec <<END;
\%{__perl} Build.PL --installdirs=$instdir@{[$mod_hash->{noarch} ? '' : qq{ optimize="$macro{optimize}"} ]} $paths
\%{__perl} -p -i -e 's/^Module::Build->VERSION/#Module::Build->VERSION/g' Build

./Build
END
    }
    else {
        print $spec qq{sed -i -e '/List::SomeUtils::XS/d' Makefile.PL\n}
            if ($mod_hash->{module} eq 'List::SomeUtils');    # recursive dep

        if ($mod_hash->{module} eq 'XML::Canonical') {
            print($spec qq{sed -i -e 's/minor == 7/minor >= 8/g' Makefile.PL\n});
            print($spec qq{sed -i -e 's/point == 1/point >= 0/g' Makefile.PL\n});
            print($spec
                    qq{sed -i -e 's/^    return/warn(\$results);\r    return/' Makefile.PL\n});
        }

        print $spec <<END;
\%{__perl} -I. Makefile.PL INSTALLDIRS=$instdir@{[$mod_hash->{noarch} ? '' : qq{ OPTIMIZE="$macro{optimize}"}]} $paths
END

        print $spec "\%{__perl} -pi -e 's/^\\tLD_RUN_PATH=[^\\s]+\\s*/\\t/' Makefile\n"
            if ($compat and !$mod_hash->{noarch});

        print $spec <<END;
make \%{?_smp_mflags}
END
    }

    print $spec <<END;

\%install
rm -rf $macro{buildroot}

END

    if ($mod_hash->{usebuildpl}) {
        print $spec "./Build install --destdir=$macro{buildroot} --create_packlist=0\n";
    }
    else {
        print $spec <<END;
make pure_install PERL_INSTALL_ROOT=$macro{buildroot} $paths

find $macro{buildroot} -type f -name .packlist -exec rm -f {} \\;
END
    }

    if (!$mod_hash->{noarch}) {
        print $spec <<END;
find $macro{buildroot} -type f -name '*.bs' -size 0 -exec rm -f {} \\;
END
    }

    print $spec <<END;
find $macro{buildroot} -depth -type d -exec rmdir {} 2>/dev/null \\;

\%{_fixperms} $macro{buildroot}/*

END

    if ($addlicense and !grep /copying|artistic|copyright|license/i, @{ $mod_hash->{doc} }) {
        print $spec <<END;
perldoc -t perlgpl > COPYING
perldoc -t perlartistic > Artistic

END

        push(@{ $mod_hash->{doc} }, "COPYING", "Artistic");
    }

    print $spec <<END;
\%check@{[($compat ? ' || :' : '')]}
END

    # some modules check their manifest and can pickup debuginfo files and such
    if (!$mod_hash->{noarch}) {
        print $spec <<'END';
cat << \EOF >> MANIFEST.SKIP
\bdebug.*.list$
\belfbins.list$
\bfilelist$
EOF
END

    }

    if ($mod_hash->{usebuildpl}) {
        print $spec "./Build test\n";
    }
    else {
        ## Move to external config file
        print $spec "make test\n"
            unless (
            ($specfile eq
                'perl-Crypt-OpenSSL-VerifyX509.spec') ## FIXME MD5 cert support dropped from Fedor
            || ($specfile eq 'perl-XML-GDOME.spec')    ## FIXME libxslt changed whitespace rules
            );
    }

    print $spec <<END;

\%clean
rm -rf $macro{buildroot}

END

    my $docs = join(' ', @{ $mod_hash->{doc} });

    print $spec <<END;
\%files
\%defattr(-,root,root,-)
\%doc $docs
END

    # BUGBUG FIXME
    my $has_modules = 1;

    # BUGBUG when does a noarch also have nolibbs?
    my $nolib = 0;

    if ($mod_hash->{iscore}) {
        if ($mod_hash->{scripts}) {
            print $spec <<END;
/usr/local/share/man/man1/*
END
        }
        print $spec <<END;
/usr/local/share/man/man3/*
END

        if ($has_modules) {
            if ($mod_hash->{noarch}) {

                if (0) {
                    print $spec <<END;
/usr/share/perl5/vendor_perl/*
END
                }
                else {
                    print $spec <<END;
/usr/local/share/perl5/*
END
                }
            }
            else {
                if (0) {
                    print $spec <<END;
%{_libdir}/perl5/vendor_perl/*
END
                }
                else {
                    print $spec <<END;
/usr/local/%{_lib}/perl5/*
END
                }
            }
        }
        if ($mod_hash->{scripts}) {
            print $spec <<END;
/usr/local/bin/*
END
        }
    }
    else {
        print $spec <<END;
\%{_mandir}/*
END
        if ($has_modules) {

            if ($mod_hash->{noarch}) {
                print $spec <<END;
/usr/share/perl5/*
END
            }
            elsif (!$nolib) {
                print $spec <<END;
%{_libdir}/perl5/*
END
            }
        }
        if ($mod_hash->{scripts}) {
            print $spec <<END;
\%{_bindir}/*
END
        }
    }

    unless ($mod_hash->{iscore}) {
        print $spec <<END;
%{_datadir}/*
END
    }

    my $date = strftime("%a %b %d %Y", localtime);

    print $spec <<END;

\%changelog
* $date $packager $mod_hash->{version}-$release
- Specfile autogenerated by $NAME $VERSION.

END

    $spec->close();

    return;
}

sub clean_build_root {
    system('rm -rf $(rpm --eval "%{_builddir}")/*');
    system('rm -rf $(rpm --eval "%{_sourcedir}")/*');
    system('rm -rf $(rpm --eval "%{_srcrpmdir}")/*');
    system('rm -rf $(rpm --eval "%{_specdir}")/*');
    system('rm -rf $(rpm --eval "%{_buildrootdir}")/*');
    system('find $(rpm --eval "%{_rpmdir}") -name "*.rpm" | xargs rm -f');
    return;
}

sub max {
    my ($x, $y) = @_;
    verbose("max 1: $x < $y\n");

    # chop off epoch for this test
    $x =~ s/^[^:]*://g;
    $y =~ s/^[^:]*://g;
    verbose("max 2: $x < $y?\n");

    my $x1 = Perl::Version->new("$x");
    my $y1 = Perl::Version->new("$y");

    return (($x, $y)[ $x1 < $y1 ]);
}

sub run_cmd {
    my @cmd = @_;

    my $cmd = '';
    foreach my $arg (@cmd) {
        if ($arg =~ /[\s\(]/ && $arg !~ /"/) {
            $cmd .= qq{"$arg" };
        }
        else {
            $cmd .= qq{$arg };
        }
    }

    if (   $cmd =~ /perl-HTTP-Date\\\*/
        || $cmd =~ /perl-HTTP-Cookie/
        || $cmd =~ /perl-libwww-perl/)
    {
        my $test = qx/rpm -e --nodeps perl-libwww-perl/;
        verbose($test);
    }
    verbose("\nRunning 2: $cmd");
    my $out = qx/$cmd 2>&1/;

    verbose("out: $out\n")                   if ($out);
    verbose("\$\@: $@\n\$!: $!\n\$\?: $?\n") if ($?);
    return ($out, $?);
}

sub run_cmd2 {
    verbose("\nRunning 3: " . join(' ', @{ $_[0] }) . " " . $_[1] . " " . join(' ', @{ $_[2] }));

    my ($in, $out_and_err);
    run($_[0], '<', \$in, $_[1], $_[2], '>&', \$out_and_err);

    #    my $cmd = join( ' ', @{ $_[0] } ) . " " . $_[1] . " " . join( ' ', @{ $_[2] } );
    #    verbose(  "\nRunning 3: $cmd");
    #    $out_and_err = qx/$cmd/;
    carp("Error: $?\nerr: $out_and_err\n\n\$\@: $@\n\$!: $!\n")
        if ($?);    #&& $! ne 'Illegal seek');
    verbose("out: $out_and_err\n") if ($out_and_err);

    return ($out_and_err);
}

sub print_version {
    print "$NAME version $VERSION\n";
    exit 0;
}

sub verbose {
    my $msg   = shift;
    my $level = shift || 1;

    if ($verbose && $level >= $verbose) {
        if ($verbose <= 3) {
            print STDERR $msg, "\n";
        }
        else {
            carp($msg);
        }
    }

    return;
}

sub fetch {
    my ($url, $file) = @_;
    my @locations = ();

    verbose("Fetching $file from $url...");

    my $ret = system("wget --quiet --output-document=$file $url");

    verbose $? if ($ret);

    return;

    my $ua = LWP::UserAgent->new('env_proxy' => 1)
        || croak("LWP::UserAgent->new() failed: $!\n");
    $ua->timeout(180);
    my $request;
LOOP: $request = HTTP::Request->new('GET' => $url)
        || croak("HTTP::Request->new() failed: $!\n");

    my @buf = stat($file);
    $request->if_modified_since($buf[9]) if (@buf);

    # FIXME - Probably should do $ua->request() here and skip loop detection.
    my $response = $ua->simple_request($request)
        || croak("LWP::UserAgent->simple_request() failed: $!\n");

    push(@locations, $url);
    if ($response->code eq "301" || $response->code eq "302") {
        $url = $response->header('Location');
        croak("Redirect loop detected! " . join("\n ", @locations, $url) . "\n")
            if (grep { $url eq $_ } @locations);
        goto LOOP;
    }

    if ($response->is_success) {
        my $fh = new FileHandle ">$file"
            || croak("Can't write to $file: $!\n");
        print $fh $response->content;
        $fh->close();

        my $last_modified = $response->last_modified;
        utime(time, $last_modified, $file) if ($last_modified);
    }
    elsif ($response->code eq "304") {
        verbose("$file is up to date.");
    }
    else {
        croak("Failed to get $url: " . $response->status_line . "\n");
    }

    return;
}

sub mkdir_p {
    my $dir = shift;
    my $cmd = qq{mkdir -p $dir };
    say "Runing: $cmd";
    my $res = system('mkdir', '-p', $dir);
    carp('$!: ' . $! . ', $@: ' . $@ . ', $?: ' . $? . ", res: $res\n") if ($res);
    croak("Failed to create dir: $@, $!") if ($res);
    return;

    my @path = split '/', $dir;

    for (my $n = 0; $n < @path; $n++) {
        my $partial = "/" . join("/", @path[ 0 .. $n ]);
        if (!-d $partial) {
            verbose("mkdir($partial)");
            mkdir $partial || croak("mkdir($partial) failed: $!\n");
        }
    }

    return;
}

sub update_packages {
    return 1 if ($updated);

    verbose("Updating $pkgdetails ...");

    mkdir_p(dirname($pkgdetails)) if (!-d dirname($pkgdetails));

    fetch("$cpan/modules/" . basename($pkgdetails), $pkgdetails);

    $updated = 1;

    return;
}

sub build_rpm {
    my $spec = shift;
    my $dir  = getcwd();

    my $rpmbuild = which("rpmbuild", "rpm");

    verbose("Building " . ($buildrpm ? "rpms" : "source rpm") . " from $spec");
    if (!-d "$spec-build") {
        verbose("mkdir($spec-build)");
        mkdir "$spec-build" || croak("mkdir($spec-build) failed: $!\n");
    }
    if (!-d "$spec-build") {
        verbose("mkdir($spec-build)");
        mkdir "$spec-build"
            || croak("mkdir($spec-build) failed: $!\n");
    }

    my ($out, $err) = run_cmd(
        $rpmbuild, "--define", "_sourcedir $dir",
        "--define", "_builddir $dir/$spec-build",
        "--define",
        "_srcrpmdir $dir/$spec-build",
        ($buildrpm ? "-ba" : ("-bs", "--nodeps")), $spec
    );

    croak("Make failed :(") if ($err);

    return;
}

sub list_files {
    my $archive = $_[0];
    my $type    = $_[1];

    if ($type eq 'tar') {
        return $archive->list_files();
    }
    elsif ($type eq 'zip') {
        return map { $_->fileName(); } $archive->members();
    }

    return;
}

sub extract {
    my $archive  = $_[0];
    my $type     = $_[1];
    my $filename = $_[2];

    if ($type eq 'tar') {
        return $archive->get_content($filename);
    }
    elsif ($type eq 'zip') {
        return $archive->contents($filename);
    }

    return;
}

sub get_description {
    my %args = @_;
    my $pm   = "";
    my ($summary, $description);

    my $path = $args{module};
    $path =~ s,::,/,g;
    my @pmfiles = ("$args{path}/lib/$path.pod", "$args{path}/lib/$path.pm");
    if ($args{module} =~ /::/) {
        my @tmp  = split '/', $path;
        my $last = pop @tmp;
        push(@pmfiles, "$args{path}/lib/$last.pod", "$args{path}/lib/$last.pm");
    }
    do {
        push(@pmfiles, "$args{path}/$path.pod", "$args{path}/$path.pm");
    } while ($path =~ s,^[^/]+/,,);
    push(@pmfiles, "$args{path}/$args{module}")
        if ($args{module} !~ /::/);

    for my $file (@pmfiles) {
        $pm = (grep { $_ eq $file || $_ eq "./$file" } list_files($args{archive}, $args{type}))
            [0];
        last if $pm;
    }

    if ($pm) {
        verbose("Trying to fetch description from $pm...");

        if (my $content = extract($args{archive}, $args{type}, $pm)) {
            my $parser = Pod::Simple::TextContent->new()
                || croak("Pod::Simple::TextContent->new() failed: $!\n");
            $parser->no_whining(1);
            my $rendered = "";
            $parser->output_string(\$rendered);
            $parser->parse_string_document($content);
            if ($parser->content_seen and $rendered) {
                if ($rendered =~ /DESCRIPTION\s+(\S.*?)\n\n/s) {
                    $description = $1;
                }
                if ($rendered =~ /NAME\s*$args{module}\s[-\s]*(\S[^\n]*)/s) {
                    if ($1 ne "SYNOPSIS") {
                        $summary = $1;
                        $summary =~ s/[.\s]+$//;
                        $summary =~ s/^(?:An?|The)\s+//i;
                        $summary = ucfirst($summary);
                    }
                }
                return ($description, $summary)
                    if (defined($description));
            }
        }
        else {
            carp "Failed to read $pm from $args{filename}"
                . (
                $args{type} eq 'tar'
                ? (": " . $args{archive}->error())
                : ""
                ) . "\n";
        }
    }

    if (my $readme
        = (sort { length($a) <=> length($b) || $a cmp $b } (grep /README/i, @{ $args{files} }))[0]
        )
    {
        verbose("Trying to fetch description from $readme...");

        if (my $content = extract($args{archive}, $args{type}, "$args{path}/$readme")) {
            $content =~ s/\r//g;    # Why people use DOS text, I'll never understand.
            for my $string (split "\n\n", $content) {
                $string =~ s/^\n+//;
                if ((my @tmp = split "\n", $string) > 2
                    and $string !~ /^[#\-=]/)
                {
                    return ($string, undef);
                }
            }
        }
        else {
            carp "Failed to read $readme from $args{filename}"
                . (
                $args{type} eq 'tar'
                ? (": " . $args{archive}->error())
                : ""
                ) . "\n";
        }
    }

    return (undef, undef);
}

sub check_rpm {
    my $dep     = shift;
    my $version = shift || 0;

    my $rpm = 'rpm';    #which("rpm");

    my @opts = ($rpm, '-q', "--qf='%{NAME}'", '--whatprovides', qq{"$dep >= $version"});
    my ($out, $err) = run_cmd2(\@opts, '|', [ 'head', '-n1' ]);

    my $package;
    $package = (split /\n/, $out)[0] if ($out);

    if ($? != 0) {
        verbose("backtick (rpm) failed with return value $?, $package");
        return;
    }
    elsif ($package =~ /no package provides/i) {
        return;
    }
    else {
        my $cmd
            = qq{rpm -q --provides "$package" | grep '$package = ' | sed -e 's/^.* =//g' -e 's/\-[^-]*\$//g'};
        verbose("running: $cmd");
        my $prov_ver = qx/$cmd/;
        really_chomp($prov_ver);

        # chop off epoch
        $prov_ver =~ s/^[^:]*://g  if (defined($prov_ver));
        $prov_ver =~ s/[a-z]*$//ig if (defined($prov_ver));
        verbose("rpm pov_version: $prov_ver\n");
        if (   !defined($prov_ver)
            || $prov_ver eq ""
            || (Perl::Version->new($version) > Perl::Version->new($prov_ver)))
        {
            verbose("Version required is greater than version provided: $version > $prov_ver");
            return;
        }
    }

    return $package;
}

sub check_repo {
    my $dep     = shift;
    my $version = shift;

    return ($repo_cache{"$dep-$version"})
        if (defined($repo_cache{"$dep-$version"}));

    my $repoquery = which("dnf");
    my @opts      = qw{repoquery --quiet --qf='%{NAME}' --latest-limit 1 --whatprovides};
    push(@opts, qq{"$dep >= $version"});
    my $opts2 = qq{repoquery --quiet --latest-limit 1 --provides};

    unless ($repoquery) {
        $repoquery = which("repoquery");
        @opts      = qw{--qf='%{epoch}:%{version}-%{release} %{NAME}' --whatprovides};
        push(@opts, qq{"$dep"});
        $opts2 = qq{ --quiet  --provides};
    }

    unshift(@opts, $repoquery);

    #    my ( $out, $err ) = run_cmd2(\@opts, '|', ['sort', '-r' ] );
    my ($out, $err) = run_cmd(@opts);

    my $package;
    my @test = grep { $_ !~ /perl$/ } reverse sort (split /\n/, $out);
    $package = $test[0];
    really_chomp($package);
    if (!$dnf) {
        $package =~ s/^\S* //g if ($package);
    }
    if ($? != 0) {
        verbose("backtick (repoquery) failed with return value $? $@");
        return;
    }

    if (!defined($package) || $package eq "") {

        # check if it's supplied by a source only repo
        if (my $pkg = check_src_rpm($dep)) {
            if (exists($dep_blacklist{$pkg})) {
                verbose(qq{Skipping black listed dep $pkg});
                return;
            }
            else {
                verbose(qq{$dep suplied by $pkg in a source only repo!});
                my $srpm = download_srpm($pkg);
                build_n_install($srpm, "$home/rpmbuild/");
                return ($pkg);
            }
        }
        else {
            verbose(qq{No package supplies $dep});
            return;
        }
    }

    # if we have versioned requires then we need to work around the
    # rpm descison that unversioned provides matches any version.
    if ($version ne "0") {

        # FIXME can we use runcmd2 for this?
        my $cmd
            = qq{$repoquery $opts2 "$package" | grep '$dep = ' | tail -n1 | sed -e 's/^.* =//g' -e 's/\-[^-]*\$//g'};

        verbose(qq{Running 4: '$cmd', this may take a long while.});

        my $prov_ver = qx/$cmd/;
        really_chomp($prov_ver);

        # chop off epoch
        $prov_ver =~ s/^[^:]*:\s*//g if (defined($prov_ver));
        verbose("pov_version: '$prov_ver'\n");
        if (   !defined($prov_ver)
            || $prov_ver eq ""
            || (Perl::Version->new($version) > Perl::Version->new($prov_ver)))
        {
            verbose("Version required is greater than version provided: $version > $prov_ver");
            return;
        }
    }

    $repo_cache{"$dep-$version"} = $package;

    return $package;
}

sub check_dep {
    my $module  = shift;
    my $version = shift;

    if (   exists($dep_blacklist{$module})
        || $module =~ /^Win32::/
        || $module =~ /^t::/
        || $module =~ /^[\d\.\_]+$/
        || $module =~ /^inc::/)
    {
        verbose(qq{Skipping black-listed dep $module});
        return;
    }

    return (check_rpm("perl($module)", $version) || check_repo("perl($module)", $version));
}

sub which {
    for my $bin (@_) {
        for my $path (split /:/, $ENV{PATH}) {
            return "$path/$bin" if -x "$path/$bin";
        }
    }
##    verbose("Cannot find " . join(" or ", @_));
    return;
}

sub check_src_rpm {
    my $pkg = shift;

    return
        if ($pkg eq 'perl(namespace::autoclean)' || $pkg =~ 'MooseX');    # broken srpms upstream

    my @cmd = qw{repoquery --quiet  --qf='%{NAME} %{VERSION}' --enablerepo=* --whatprovides};

    @cmd = qw{/usr/bin/dnf  --quiet repoquery --qf='%{NAME}' --recent --whatprovides}
        if ($dnf);

    push(@cmd, "'$pkg'");

    #    verbose("check_src_rpm running:  $cmd");
    #    my $result = qx/$cmd/;
    my ($out, $err) = run_cmd(@cmd);
    my $result;
    $result = (split /\n/, $out)[0] if ($out);

#BUGBUG Use of uninitialized value $result in concatenation (.) or string at /cpanspec/cpanspec line 2885.

    really_chomp($result);
    verbose("result: $result");
    my ($rpm, $ver);
    ($rpm, $ver) = split(/ /, $result) if ($result);
    return ($rpm);
}

sub download_srpm {
    my $pkg = shift;

    return
        if ($pkg eq 'perl(namespace::autoclean)' || $pkg =~ 'MooseX');    # broken srpm upstream

    my $dir = "$wd_path/$pkg";
    $dir =~ s/perl\((.*)\)/perl-$1/;
    $dir =~ s/::/-/g;
    $dir =~ s/[ >=<]//g;
    mkdir_p($dir) if (!-d ($dir));

    if ($dnf) {
        run_cmd(
            $dnf,       'download',       '--quiet',       '--nogpgcheck',
            '--source', '--enablerepo=*', '--downloaddir', $dir,
            $pkg
        );
    }
    else {
        run_cmd('yumdownloader', '--quiet', '--nogpgcheck', '--source',
            '--enablerepo=*', '--destdir', $dir, $pkg);
    }

    my @files = glob("$dir/*.src.rpm");
    return ($files[0]);
}

sub rebuild_srpm {
    my $srpm = shift;

    my ($out, $err) = run_cmd('rpmbuild', '--rebuild', $srpm);
    croak("rpmbuild failed :(") if ($err);

    return;
}

sub build_n_install {
    my $pkg  = shift;
    my $dirs = shift;

## FIXME there is no version handling here
    my $package = $pkg;
    $package =~ s/perl\((.*)\).*/$1/;
##    $package =~ s/::/-/g;

    verbose("Building $package");

    if (grep { $_ eq $package } @processed) {
        verbose("Skipping $package already processed");
    }
    else {

        install_deps($pkg);
        if (grep { $_ eq $package } @processed) {
            verbose("Skipping $package processed by a dep");
            return;
        }

        my $name;
        if ($pkg =~ m{([^/]*)\.spec}) {
            $name = $1;
            build_rpm($pkg);
        }
        else {
            my ($out, $err) = run_cmd('rpm', '-q', '--qf', '%{NAME}', '-p', $pkg);    # --nogpg
            $name = $out;
            rebuild_srpm($pkg);
        }

        install_pkg($dirs, $name);

        push(@processed, $package);
    }
    return;
}

sub install_deps {
    my $file = shift;

    my ($std, $err, @missing);

    verbose("Installing deps for $file");

    if ($dnf) {
        ($std, $err) = run_cmd(qw{dnf -y builddep }, $file);
    }
    else {
        ($std, $err) = run_cmd('yum-builddep', '-t', '-y', $file);

    }
    verbose("std: $std\n\nerr: $err");

    # &^%&%$ dnf switched this to std err
    foreach (split("\n", $std . "\n" . $err)) {
        push(@missing, $_)
            if ($_ =~ /No Package found for/i
            || $_ =~ /No matching package to install/i);
    }

    foreach my $dep (@missing) {
        really_chomp($dep);
        $dep =~ s/Error: No Package found for //i;
        $dep =~ s/No matching package to install: //i;
        $dep =~ s/-devel//;
        $dep =~ s/'//g;

        my $package = $dep;
        $package =~ s/perl\((.*)\).*/$1/;
        $package =~ s/::/-/g;

        unless (grep { $_ eq $package } @processed) {
            verbose("Building missing dep $dep for $file");
            my $srpm;
            eval { $srpm = download_srpm($dep); };
            if ($srpm) {
                build_n_install($srpm, "/$home/rpmbuild/");
            }
            else {
                my $spec = "perl-$package.spec";
                process_module($package);
            }
            verbose("Completed missing dep $package for $file\n");
            push(@processed, $package);
        }
    }

    ## BUGBUG yum-buidldep stopped installing found packages if any where missing, maybe someone broek --tolerant?
    if (@missing) {
        if ($dnf) {
            ($std, $err) = run_cmd(qw{dnf -y builddep }, $file);
        }
        else {
            ($std, $err) = run_cmd('yum-builddep', '-t', '-y', $file);

        }
    }

    return;
}

sub create_repo {
    unless (-d "$repo_path") {
        run_cmd('mkdir', '-p', "$repo_path");
    }
    run_cmd('createrepo', '-v', "$repo_path");

    unless (-d "$repo_path/../SRPMS") {
        run_cmd('mkdir', '-p', "$repo_path/../SRPMS");
    }

    return;
}

sub install_pkg {
    my $paths = shift;
    my $name  = shift;

    my $cmd = 'yum';
    $cmd = 'dnf' if ($dnf);

    run_cmd2([ 'find', $paths, '-name', "*.rpm", '-type', 'f' ],
        '|', [ 'xargs', '--no-run-if-empty', 'cp', '-v', '-f', '-a', '-t', "$repo_path" ]);
    run_cmd('createrepo', '-v', '--update', "$repo_path");
    run_cmd($cmd, '--disablerepo=*', '--enablerepo', 'cpanspec', 'clean', 'expire-cache');

    clean_build_root();

    my ($res, $err);

    if ($dnf) {
        run_cmd($cmd, 'makecache', '--repo', 'cpanspec');
    }
    else {
        run_cmd($cmd, '--disablerepo=*', '--enablerepo', 'cpanspec', 'makecache');
    }

    croak($err) if ($err);

    ($res, $err) = run_cmd($cmd, '-y', 'install', '--nogpgcheck', "$repo_path/*.rpm");

    croak($err) if ($err && ($err !~ /Error: Nothing to do/ms));

    return;
}

sub get_provides {
    my %args = @_;
    my %provides;
    verbose("Checking provides for " . $args{module});

    foreach my $file (@{ $args{files} }) {
        next if ($file !~ m{\.pm$} || $file =~ m{^inc/});

        if ($args{type} eq 'zip') {
            $args{archive}->extractMember("$args{path}/$file", 'tmp.pm');
        }
        else {
            $args{archive}->extract_file("$args{path}/$file", 'tmp.pm');
        }
        verbose(qx{/usr/lib/rpm/perl.prov tmp.pm});
        foreach my $pkg (qx{/usr/lib/rpm/perl.prov tmp.pm}) {
            really_chomp($pkg);
            $pkg =~ s/^perl\(//;
            $pkg =~ s/\).*$//;     # FIXME grab version?
            if ($pkg
                !~ /^(?:$args{module}|Module::AutoInstall|Module::Install.*|Win32.*|.*MyBuilder)$/
                )
            {
                $provides{$pkg} = $pkg;
                verbose("Adding $pkg as a provide of " . $args{module});
            }
        }
        unlink('tmp.pm');
    }
    return (%provides);

}

sub really_chomp {
    return unless ($_[0]);
    chomp($_[0]);
    $_[0] =~ s/\R$//g;

    return;
}

sub _proc_meta {
    my ($mod_hash) = @_;

    my $meta = $mod_hash->{meta};
    printf "testing requirements for %s version %s\n", $meta->name, $meta->version;

    my $prereqs = $meta->effective_prereqs;

    my @types = qw/requires/;

    # BUGBUG work out if reccomnds works on this O/S...
    push(@types, "recommends") if (0);

    my $reqs = $prereqs->merged_requirements([ 'configure', 'build', 'test' ], \@types);

    for my $module ($reqs->required_modules) {
        next if (exists $dep_blacklist{$module});
        my $req = $reqs->structured_requirements_for_module($module);
        if ($module eq 'perl') {
            $mod_hash->{build_requires}->{$module} = $req->[0][1];
        }
        else {
            $mod_hash->{build_requires_perl}->{$module} = $req->[0][1];
        }
    }

    $reqs = $prereqs->merged_requirements(["runtime"], \@types);
    for my $module ($reqs->required_modules) {
        next if (exists $dep_blacklist{$module});
        my $req = $reqs->structured_requirements_for_module($module);
        if ($module eq 'perl') {
            $mod_hash->{requires}->{$module}       = $req->[0][1];
            $mod_hash->{build_requires}->{$module} = $req->[0][1];
        }
        else {
            $mod_hash->{requires_perl}->{$module}       = $req->[0][1];
            $mod_hash->{build_requires_perl}->{$module} = $req->[0][1];
        }
    }

    # FIXME - I'm not sure this is sufficient...
    if (   $meta->{script_files}
        || $meta->{scripts}
        || (grep m{^bin/.+$|^script(s)?/.+|^arch/.+$}, @{ $mod_hash->{files} }))
    {
        $mod_hash->{scripts} = 1;
    }

    return;
}

sub _proc_lic {
    my ($mod_hash) = @_;

    my $license = "";

    foreach my $lic (@{ $mod_hash->{meta}->{license} }) {

        # This list of licenses is from the Module::Build::API
        # docs, cross referenced with the list of licenses in
        # /usr/share/rpmlint/config.
        if ($lic =~ /^perl$/i || $lic =~ /^perl_5$/i) {
            $license = "GPL+ or Artistic, ";
        }
        elsif ($lic =~ /^apache$/i) {
            $license = "Apache Software License, ";
        }
        elsif ($lic =~ /^artistic$/i) {
            $license = "Artistic, ";
        }
        elsif ($lic =~ /^artistic_?2$/i) {
            $license = "Artistic 2.0, ";
        }
        elsif ($lic =~ /^bsd$/i) {
            $license = "BSD, ";
        }
        elsif ($lic =~ /^gpl$/i) {
            $license = "GPL+, ";
        }
        elsif ($lic =~ /^lgpl$/i) {
            $license = "LGPLv2+, ";
        }
        elsif ($lic =~ /^mit$/i) {
            $license = "MIT, ";
        }
        elsif ($lic =~ /^mozilla$/i) {
            $license = "MPL, ";
        }
        elsif ($lic =~ /^cc0$/i) {
            $license = "CC0, ";
        }
        elsif ($lic =~ /^open_source$/i) {
            $license = "OSI-Approved, ";    # rpmlint will complain
        }
        elsif ($lic =~ /^unrestricted$/i) {
            $license = "Distributable, ";
        }
        elsif ($lic =~ /^restrictive$/i) {
            $license = "Non-distributable, ";
            carp "License is 'restrictive'." . "  This package should not be redistributed.\n";
        }
        else {
            carp "Unknown license '" . $lic . "'!\n";
            $license = "CHECK(Distributable), ";
        }
    }

    if (my @licenses = grep /license|copyright|copying/i, @{ $mod_hash->{doc} }) {
        if (!$license) {
            $license = "Distributable, see @licenses, ";
        }
        elsif ($license =~ /^(OSI-Approved|Distributable|Non-distributable)$/) {
            $license .= ", see @licenses, ";
        }
    }
    $license = "CHECK(GPL+ or Artistic), " if (!$license);

    chop($license);
    chop($license);
    $mod_hash->{license} = $license;

    return;
}
